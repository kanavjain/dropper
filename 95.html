<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Weirdcore Synesthetic Visualizer</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000000; /* OLED black */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gpuCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gpuCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            console.error('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                throw new Error('Shader compile error');
            }
            return shader;
        }

        // Simple shaders for weirdcore effect
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        const fragmentShaderSource = `
            precision mediump float;
            varying vec2 v_uv;
            uniform float u_time;
            uniform float u_amplitude;

            // Function to generate random noise
            float random(vec2 co) {
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            void main() {
                // Distorted UV coordinates for a fluid effect
                vec2 uv = v_uv;
                uv.x += 0.1 * sin(uv.y * 10.0 + u_time * 0.5 + u_amplitude);
                uv.y += 0.1 * cos(uv.x * 10.0 - u_time * 0.5 + u_amplitude);
                
                // Generate noise based on UV coordinates
                float noise = random(uv * u_time * 0.1);

                // Create weirdcore colors
                vec3 color = vec3(
                    0.5 + 0.5 * sin(uv.x * 10.0 + u_time + noise + u_amplitude * 5.0),
                    0.5 + 0.5 * cos(uv.y * 15.0 - u_time * 0.8 + noise + u_amplitude * 5.0),
                    0.5 + 0.5 * sin((uv.x + uv.y) * 5.0 + u_time * 0.3 + u_amplitude * 5.0)
                );

                // Add random flicker for unsettling effect
                color *= 0.8 + 0.2 * random(uv * u_time);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Create and link program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link failed: ' + gl.getProgramInfoLog(program));
            throw new Error('Program link error');
        }
        gl.useProgram(program);

        // Set up geometry
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Set up uniform for time and amplitude
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const amplitudeLocation = gl.getUniformLocation(program, 'u_amplitude');

        // Audio setup for sound reactivity
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 128;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);

        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
        }).catch((err) => {
            console.error('Audio input error: ', err);
        });

        // Touch and gyroscope setup for interactivity
        let touchAmplitude = 0;
        window.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            touchAmplitude = (touch.clientX / window.innerWidth) * 2.0 - 1.0;
        });

        window.addEventListener('deviceorientation', (event) => {
            const { alpha, beta, gamma } = event;
            touchAmplitude = (gamma / 90.0) * 0.5; // Use gamma (left-to-right tilt) to influence amplitude
        });

        // Render loop
        function render(time) {
            analyser.getByteFrequencyData(dataArray);
            let amplitude = 0.0;
            for (let i = 0; i < dataArray.length; i++) {
                amplitude += dataArray[i];
            }
            amplitude = Math.pow((amplitude / dataArray.length) / 128.0, 2.0); // Increase sensitivity and make it more obvious

            // Combine audio amplitude with touch/gyroscope amplitude
            amplitude += touchAmplitude;

            gl.uniform1f(timeLocation, time * 0.001);
            gl.uniform1f(amplitudeLocation, amplitude);

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
