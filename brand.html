<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Star Guitar Visualizer</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
        }
        canvas {
            display: block;
        }
        #helpOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            text-align: center;
        }
        #helpOverlay button {
            margin-top: 20px;
            padding: 10px 20px;
            background: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #helpOverlay button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="helpOverlay">
        <h1>Welcome to the Interactive Visualizer!</h1>
        <p>Use mouse or touch gestures to interact:</p>
        <ul>
            <li><strong>Mouse:</strong> Click and drag to rotate, scroll to zoom.</li>
            <li><strong>Touch:</strong> Swipe to rotate, pinch to zoom.</li>
            <li><strong>Mobile:</strong> Tilt your device to change the view.</li>
        </ul>
        <button id="startButton">Start Visualizer</button>
    </div>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include Hammer.js for touch gestures -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, clock;
        let analyser, frequencyData;
        let lastAudioUpdateTime = 0;
        const audioUpdateInterval = 50; // Update every 50ms
        let cameraRotation = { x: 0, y: 0 };
        let isDeviceOrientationAvailable = false;
        let sensitivity = 0.005; // Default sensitivity

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 200);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 5);
            camera.rotation.order = 'YXZ'; // Use YXZ order for proper clamping

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xddddff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffcc88, 0.8);
            directionalLight.position.set(0, 50, -50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Initialize scene elements
            createSky();
            createGround();
            createRoad();
            createScenery();

            // Initialize clock
            clock = new THREE.Clock();

            // Setup interactions
            setupInteraction();

            // Show help overlay
            document.getElementById('startButton').addEventListener('click', function() {
                document.getElementById('helpOverlay').style.display = 'none';
                setupAudio();
                animate();
            });
        }

        // Functions to create scene elements (createSky, createGround, etc.)
        // [Omitted for brevity]

        // Setup audio with error handling
        function setupAudio() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('getUserMedia not supported on your browser!');
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function(stream) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    frequencyData = new Uint8Array(analyser.frequencyBinCount);
                })
                .catch(function(err) {
                    console.error('The following gUM error occurred: ' + err);
                });
        }

        // Advanced sound mapping with optimized updates
        function updateSceneryWithSound() {
            const now = Date.now();
            if (analyser && now - lastAudioUpdateTime > audioUpdateInterval) {
                lastAudioUpdateTime = now;
                analyser.getByteFrequencyData(frequencyData);

                // Process frequency data
                const bass = getFrequencyRangeValue(0, 10);
                const mid = getFrequencyRangeValue(11, 40);
                const treble = getFrequencyRangeValue(41, 60);

                // Update camera shake based on bass
                cameraShakeAmplitude = bass / 5000;

                // Update object colors based on mid frequencies
                const colorValue = Math.min(1, mid / 255);
                updateObjectColors(colorValue);

                // Update cloud opacity based on treble frequencies
                const opacityValue = Math.min(1, treble / 255);
                updateCloudOpacity(opacityValue);

                // Beat detection and object spawning
                handleBeatDetection();
            }
        }

        function getFrequencyRangeValue(start, end) {
            const slice = frequencyData.slice(start, end);
            const sum = slice.reduce((a, b) => a + b, 0);
            return sum / slice.length;
        }

        function updateObjectColors(value) {
            scenery.forEach(obj => {
                if (obj.material && obj.userData.isDynamicColor) {
                    obj.material.color.setHSL(value, 0.7, 0.5);
                }
            });
        }

        function updateCloudOpacity(value) {
            cloudParticles.forEach(cloud => {
                cloud.material.opacity = 0.5 + value * 0.5;
            });
        }

        function handleBeatDetection() {
            // Implement a more sophisticated beat detection algorithm here
            // For now, we'll use a simple placeholder
        }

        // Interaction setup with improved controls
        function setupInteraction() {
            // Mouse controls
            setupMouseControls();

            // Touch controls
            setupTouchControls();

            // Device orientation
            setupDeviceOrientation();
        }

        function setupMouseControls() {
            let isMouseDown = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', function (e) {
                isMouseDown = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', function (e) {
                if (isMouseDown) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    cameraRotation.y -= deltaMove.x * sensitivity;
                    cameraRotation.x -= deltaMove.y * sensitivity;
                    clampCameraRotation();

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            document.addEventListener('mouseup', function () {
                isMouseDown = false;
            });

            // Mouse wheel for zoom
            document.addEventListener('wheel', function (e) {
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(1, Math.min(100, camera.position.z));
            });
        }

        function setupTouchControls() {
            const hammer = new Hammer(renderer.domElement);
            hammer.get('pinch').set({ enable: true });
            hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

            let initialPinchDistance = null;
            let initialCameraPositionZ = camera.position.z;
            let isPinching = false;

            hammer.on('pinchstart', function (ev) {
                isPinching = true;
                initialPinchDistance = ev.scale;
                initialCameraPositionZ = camera.position.z;
            });

            hammer.on('pinchend', function () {
                isPinching = false;
            });

            hammer.on('pinch', function (ev) {
                if (isPinching) {
                    const scaleFactor = initialPinchDistance / ev.scale;
                    camera.position.z = initialCameraPositionZ * scaleFactor;
                    camera.position.z = Math.max(1, Math.min(100, camera.position.z));
                }
            });

            hammer.on('pan', function (ev) {
                if (!isPinching) {
                    cameraRotation.y -= ev.deltaX * sensitivity * 0.1;
                    cameraRotation.x -= ev.deltaY * sensitivity * 0.1;
                    clampCameraRotation();
                }
            });
        }

        function setupDeviceOrientation() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', function (event) {
                    if (event.beta !== null && event.gamma !== null) {
                        isDeviceOrientationAvailable = true;
                        const beta = THREE.Math.degToRad(event.beta); // X-axis
                        const gamma = THREE.Math.degToRad(event.gamma); // Y-axis
                        camera.rotation.x = beta;
                        camera.rotation.y = gamma;
                    }
                }, true);
            } else {
                console.warn('DeviceOrientationEvent is not supported');
            }
        }

        function clampCameraRotation() {
            const maxRotationX = Math.PI / 2; // Limit to 90 degrees up/down
            cameraRotation.x = Math.max(-maxRotationX, Math.min(maxRotationX, cameraRotation.x));
            camera.rotation.x = cameraRotation.x;
            camera.rotation.y = cameraRotation.y;
        }

        // Main animation loop with performance considerations
        function animate() {
            requestAnimationFrame(animate);

            // Update scenery with sound
            updateSceneryWithSound();

            // Move scenery elements and update interactions
            // [Rest of the animate function, including moving objects, updating camera shake, etc.]

            renderer.render(scene, camera);
        }

        // Initialize the visualizer
        init();
    </script>
</body>
</html>
