<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Guitar Inspired Visualizer</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();

        // Fog for depth perception
        scene.fog = new THREE.Fog(0x000000, 10, 200);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);
        camera.rotation.x = -0.05;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Enable shadows
        document.body.appendChild(renderer.domElement);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xddddff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffcc88, 0.8);
        directionalLight.position.set(0, 50, -50);
        directionalLight.castShadow = true; // Enable shadows
        scene.add(directionalLight);

        // Gradient Sky
        const vertexShader = `
            varying vec2 vUV;
            void main() {
                vUV = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        `;

        const fragmentShader = `
            varying vec2 vUV;
            void main() {
                vec3 skyColor = mix(vec3(0.1, 0.2, 0.5), vec3(0.8, 0.9, 1.0), vUV.y);
                gl_FragColor = vec4( skyColor, 1.0 );
            }
        `;

        const skyGeo = new THREE.SphereGeometry(500, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.5;
        ground.receiveShadow = true;
        scene.add(ground);

        // Road with stripes
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);

        // Road parameters
        const roadWidth = 4;
        const stripeLength = 2;
        const stripeSpacing = 4;
        const totalStripes = 50;

        // Create road base
        const roadGeo = new THREE.PlaneGeometry(roadWidth, 1000);
        const roadMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = -1.49;
        road.receiveShadow = true;
        scene.add(road);

        // Create stripes
        const stripeGeo = new THREE.PlaneGeometry(0.2, stripeLength);
        const stripeMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        for (let i = 0; i < totalStripes; i++) {
            const stripe = new THREE.Mesh(stripeGeo, stripeMat);
            stripe.rotation.x = -Math.PI / 2;
            stripe.position.y = -1.48; // Slightly above the road
            stripe.position.z = -i * (stripeLength + stripeSpacing);
            roadGroup.add(stripe);
        }

        // Scenery elements
        const scenery = [];

        // Function to create buildings
        function createBuilding(x, z, height = null, isSpectrograph = false) {
            const buildingHeight = height || Math.random() * 5 + 2;
            const geometry = new THREE.BoxGeometry(1, buildingHeight, 1);
            const material = new THREE.MeshLambertMaterial({ color: isSpectrograph ? 0xff0000 : 0x888888 });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, buildingHeight / 2 - 1.5, z);
            building.castShadow = true;
            building.receiveShadow = true;

            if (isSpectrograph) {
                // Store initial positions for perspective adjustment
                building.userData = {
                    initialX: x,
                    initialZ: z,
                    layer: 'midground',
                };
            } else {
                building.userData = { layer: 'midground' };
            }

            scene.add(building);
            scenery.push(building);
        }

        // Function to create trees
        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, -1, z);
            trunk.castShadow = true;

            const leavesGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, 0, z);
            leaves.castShadow = true;
            leaves.receiveShadow = true;

            trunk.userData = { layer: 'foreground' };
            leaves.userData = { layer: 'foreground' };

            scene.add(trunk);
            scene.add(leaves);
            scenery.push(trunk, leaves);
        }

        // Function to create billboards
        function createBillboard(x, z) {
            const geometry = new THREE.PlaneGeometry(2, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
            const billboard = new THREE.Mesh(geometry, material);
            billboard.position.set(x, 0, z);
            billboard.rotation.y = Math.PI / 2;
            billboard.castShadow = true;
            billboard.receiveShadow = true;
            billboard.userData = { layer: 'foreground' };

            scene.add(billboard);
            scenery.push(billboard);
        }

        // Function to create pylons
        function createPylon(x, z) {
            const geometry = new THREE.BoxGeometry(0.2, 5, 0.2);
            const material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
            const pylon = new THREE.Mesh(geometry, material);
            pylon.position.set(x, 2.5 - 1.5, z);
            pylon.castShadow = true;
            pylon.receiveShadow = true;
            pylon.userData = { layer: 'background' };

            scene.add(pylon);
            scenery.push(pylon);
        }

        // Function to create bridges
        function createBridge(z) {
            const geometry = new THREE.BoxGeometry(10, 1, 2);
            const material = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const bridge = new THREE.Mesh(geometry, material);
            bridge.position.set(0, -1, z);
            bridge.castShadow = true;
            bridge.receiveShadow = true;
            bridge.userData = { layer: 'midground' };

            scene.add(bridge);
            scenery.push(bridge);
        }

        // Populate initial scenery
        for (let i = 0; i < 50; i++) {
            const z = -Math.random() * 300;
            const side = Math.random() > 0.5 ? 1 : -1;
            const x = side * (Math.random() * 10 + roadWidth / 2 + 1);
            const type = Math.random();
            if (type < 0.4) {
                createBuilding(x, z);
            } else if (type < 0.6) {
                createTree(x, z);
            } else if (type < 0.8) {
                createBillboard(x, z);
            } else if (type < 0.9) {
                createPylon(x, z);
            } else {
                createBridge(z);
            }
        }

        // Audio setup
        let analyser;
        let audioContext;
        let frequencyData;
        let lastSpectrographTime = 0;
        const spectrographInterval = 300; // Generate new towers every 300ms

        let lastBeatTime = 0;
        const beatThreshold = 200;
        const minBeatInterval = 300;

        navigator.mediaDevices
            .getUserMedia({ audio: true })
            .then((stream) => {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                audioSource.connect(analyser);
            })
            .catch((err) => {
                console.error('Audio input error: ', err);
            });

        // Camera shake variables
        let cameraBaseY = camera.position.y;
        let cameraShakeAmplitude = 0.05;
        let cameraShakeFrequency = 0.005;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            let bass = 0;
            if (analyser) {
                analyser.getByteFrequencyData(frequencyData);
                bass = frequencyData.slice(0, 10).reduce((a, b) => a + b, 0) / 10;

                // Simple beat detection
                const lowerHalfArray = frequencyData.slice(0, frequencyData.length / 2 - 1);
                const total = lowerHalfArray.reduce((sum, value) => sum + value, 0);
                const average = total / lowerHalfArray.length;

                if (average > beatThreshold && Date.now() - lastBeatTime > minBeatInterval) {
                    lastBeatTime = Date.now();
                    createSynchronizedObject();
                }
            }

            const speed = 0.5 + bass / 100;

            // Move scenery elements towards the camera
            for (let i = scenery.length - 1; i >= 0; i--) {
                const obj = scenery[i];
                let layerSpeed = speed;
                if (obj.userData.layer === 'foreground') {
                    layerSpeed = speed * 1.2;
                } else if (obj.userData.layer === 'background') {
                    layerSpeed = speed * 0.8;
                }
                obj.position.z += layerSpeed;

                // Adjust x position for perspective effect (spectrograph towers)
                if (obj.userData && obj.userData.initialX !== undefined) {
                    const zFactor = (obj.position.z + 300) / 300; // Normalized between 0 (far) and 1 (near)
                    // Apply a non-linear spread function
                    const spreadMultiplier = Math.pow(zFactor, 2) * 20; // Adjust exponent and multiplier as needed
                    obj.position.x = obj.userData.initialX * spreadMultiplier;

                    // Ensure buildings stay outside the road as they get closer
                    const minX = roadWidth / 2 + 1; // Minimum x distance from center to avoid road
                    if (Math.abs(obj.position.x) < minX && zFactor > 0.5) {
                        obj.position.x = Math.sign(obj.userData.initialX) * minX;
                    }
                }

                if (obj.position.z > 5) {
                    // Remove objects that have passed the camera
                    scene.remove(obj);
                    scenery.splice(i, 1);
                }
            }

            // Generate new spectrograph towers at intervals
            if (analyser && Date.now() - lastSpectrographTime > spectrographInterval) {
                lastSpectrographTime = Date.now();
                const barCount = 32;
                const startX = -((barCount - 1) * 0.5) / 2;

                for (let i = 0; i < barCount; i++) {
                    const frequency = frequencyData[i];
                    const height = Math.max(frequency / 20, 0.1);
                    const xNormalized = (i / (barCount - 1)) * 2 - 1;
                    const x = xNormalized * 0.5; // Start closer to the center
                    const z = -300;
                    createBuilding(x, z, height, true);
                }
            }

            // Move road stripes
            roadGroup.children.forEach((stripe) => {
                stripe.position.z += speed;
                if (stripe.position.z > 5) {
                    stripe.position.z -= totalStripes * (stripeLength + stripeSpacing);
                }
            });

            // Camera shake to simulate train movement
            camera.position.y = cameraBaseY + Math.sin(Date.now() * cameraShakeFrequency) * cameraShakeAmplitude;

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Function to create synchronized objects
        function createSynchronizedObject() {
            const type = Math.random();
            const z = -300;
            const side = Math.random() > 0.5 ? 1 : -1;
            const x = side * (Math.random() * 10 + roadWidth / 2 + 1);

            if (type < 0.3) {
                createBuilding(x, z);
            } else if (type < 0.6) {
                createTree(x, z);
            } else if (type < 0.8) {
                createPylon(x, z);
            } else {
                createBillboard(x, z);
            }
        }
    </script>
</body>
</html>
