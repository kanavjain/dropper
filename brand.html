<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Guitar Visualizer with Road Stripes</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();

        // Fog for depth perception
        scene.fog = new THREE.Fog(0x000000, 10, 200);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 2, 5);
        camera.rotation.x = -0.05;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffddaa, 0.8);
        directionalLight.position.set(0, 50, -50);
        scene.add(directionalLight);

        // Gradient Sky
        const vertexShader = `
            varying vec2 vUV;
            void main() {
                vUV = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        `;

        const fragmentShader = `
            varying vec2 vUV;
            void main() {
                vec3 skyColor = mix(vec3(0.1, 0.2, 0.5), vec3(0.8, 0.9, 1.0), vUV.y);
                gl_FragColor = vec4( skyColor, 1.0 );
            }
        `;

        const skyGeo = new THREE.SphereGeometry(500, 32, 15);
        const skyMat = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            side: THREE.BackSide,
        });
        const sky = new THREE.Mesh(skyGeo, skyMat);
        scene.add(sky);

        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(1000, 1000);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.5;
        scene.add(ground);

        // Road with stripes
        const roadGroup = new THREE.Group();
        scene.add(roadGroup);

        // Road parameters
        const roadWidth = 4;
        const stripeLength = 2;
        const stripeSpacing = 4;
        const totalStripes = 50;

        // Create road base
        const roadGeo = new THREE.PlaneGeometry(roadWidth, 1000);
        const roadMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = -1.49;
        scene.add(road);

        // Create stripes
        const stripeGeo = new THREE.PlaneGeometry(0.2, stripeLength);
        const stripeMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
        for (let i = 0; i < totalStripes; i++) {
            const stripe = new THREE.Mesh(stripeGeo, stripeMat);
            stripe.rotation.x = -Math.PI / 2;
            stripe.position.y = -1.48; // Slightly above the road
            stripe.position.z = -i * (stripeLength + stripeSpacing);
            roadGroup.add(stripe);
        }

        // Scenery elements
        const scenery = [];

        // Function to create buildings
        function createBuilding(x, z, height = null) {
            const buildingHeight = height || Math.random() * 5 + 2;
            const geometry = new THREE.BoxGeometry(1, buildingHeight, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, buildingHeight / 2 - 1.5, z);
            scene.add(building);
            scenery.push(building);
        }

        // Function to create trees
        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, -1, z);

            const leavesGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(x, 0, z);

            scene.add(trunk);
            scene.add(leaves);
            scenery.push(trunk, leaves);
        }

        // Function to create billboards
        function createBillboard(x, z) {
            const geometry = new THREE.PlaneGeometry(2, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
            const billboard = new THREE.Mesh(geometry, material);
            billboard.position.set(x, 0, z);
            billboard.rotation.y = Math.PI / 2;
            scene.add(billboard);
            scenery.push(billboard);
        }

        // Populate initial scenery
        for (let i = 0; i < 50; i++) {
            const z = -Math.random() * 300;
            const side = Math.random() > 0.5 ? 1 : -1;
            const x = side * (Math.random() * 10 + 5);
            const type = Math.random();
            if (type < 0.5) {
                createBuilding(x, z);
            } else if (type < 0.8) {
                createTree(x, z);
            } else {
                createBillboard(x, z);
            }
        }

        // Audio setup
        let analyser;
        let audioContext;
        let frequencyData;
        let lastSpectrographTime = 0;
        const spectrographInterval = 500; // Generate new towers every 500ms

        navigator.mediaDevices
            .getUserMedia({ audio: true })
            .then((stream) => {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                frequencyData = new Uint8Array(analyser.frequencyBinCount);
                audioSource.connect(analyser);
            })
            .catch((err) => {
                console.error('Audio input error: ', err);
            });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            let bass = 0;
            if (analyser) {
                analyser.getByteFrequencyData(frequencyData);
                bass = frequencyData.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
            }

            const speed = 0.5 + bass / 100;

            // Move scenery elements towards the camera
            for (let i = scenery.length - 1; i >= 0; i--) {
                const obj = scenery[i];
                obj.position.z += speed;
                if (obj.position.z > 5) {
                    // Remove objects that have passed the camera
                    scene.remove(obj);
                    scenery.splice(i, 1);
                }
            }

            // Generate new spectrograph towers at intervals
            if (analyser && Date.now() - lastSpectrographTime > spectrographInterval) {
                lastSpectrographTime = Date.now();
                const barCount = 32;
                const barSpacing = 0.5;
                const startX = -((barCount - 1) * barSpacing) / 2;

                for (let i = 0; i < barCount; i++) {
                    const frequency = frequencyData[i];
                    const height = Math.max(frequency / 20, 0.1);
                    const x = startX + i * barSpacing;
                    const z = -300; // Horizon position
                    createBuilding(x, z, height);
                }
            }

            // Move road stripes
            roadGroup.children.forEach((stripe) => {
                stripe.position.z += speed;
                if (stripe.position.z > 5) {
                    stripe.position.z -= totalStripes * (stripeLength + stripeSpacing);
                }
            });

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
