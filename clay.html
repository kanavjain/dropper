<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic WebGL Audio Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      color: white;
      font-family: Arial, sans-serif;
    }
    #controls label {
      margin-right: 10px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script> <!-- Adding Perlin Noise library -->
</head>
<body>
  <canvas id="visualizer"></canvas>
  <div id="controls">
    <label>Color</label>
    <input type="color" id="colorPicker" value="#ffffff">
    <label>Sensitivity</label>
    <input type="range" id="sensitivity" min="0.1" max="5" step="0.1" value="1">
  </div>

  <script>
    let scene, camera, renderer, particles, analyser, dataArray, uniforms;
    const canvas = document.getElementById('visualizer');
    const colorPicker = document.getElementById('colorPicker');
    const sensitivitySlider = document.getElementById('sensitivity');
    const mouse = { x: 0, y: 0 };
    let sensitivity = 1;
    let lastLowPeak = 0;

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      // Renderer setup
      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Audio setup
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        // Create particle system
        createParticles();

        // Start animation loop
        animate();
      }).catch(err => {
        console.error('Audio access denied:', err);
      });

      // Handle resize
      window.addEventListener('resize', onResize);
      document.addEventListener('mousemove', onMouseMove);

      // Update sensitivity and color
      sensitivitySlider.addEventListener('input', () => {
        sensitivity = parseFloat(sensitivitySlider.value);
      });
      colorPicker.addEventListener('input', () => {
        uniforms.color.value.set(colorPicker.value);
      });
    }

    function createParticles() {
      const particleCount = 5000; // Fewer particles
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;

        // Faster velocity for more dynamic motion
        velocities[i * 3] = (Math.random() - 0.5) * 2.0; // Increase speed
        velocities[i * 3 + 1] = (Math.random() - 0.5) * 2.0;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 2.0;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

      uniforms = {
        time: { value: 0 },
        mouse: { value: new THREE.Vector2() },
        audioData: { value: new Float32Array(128) },
        color: { value: new THREE.Color(colorPicker.value) },
        sensitivity: { value: sensitivity }
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader(),
        fragmentShader: fragmentShader(),
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function vertexShader() {
      return `
        uniform float time;
        uniform vec2 mouse;
        uniform float audioData[128];
        uniform float sensitivity;

        attribute vec3 velocity;
        varying vec3 vColor;

        float perlinNoise(float x, float y, float z) {
          return noise.simplex3(x, y, z);
        }

        void main() {
          vec3 newPosition = position + velocity * time * 0.5; // Faster movements

          float bass = audioData[0] * sensitivity;
          float mid = audioData[64] * sensitivity;
          float treble = audioData[128] * sensitivity;

          float noiseFactor = perlinNoise(newPosition.x, newPosition.y, time);
          newPosition.x += sin(time + position.x * noiseFactor) * bass * 0.5;
          newPosition.y += cos(time + position.y * noiseFactor) * mid * 0.4;

          gl_PointSize = 8.0 + bass * 20.0; // Larger particles

          vColor = vec3(
            0.5 + 0.5 * sin(time + bass),
            0.5 + 0.5 * cos(time + mid),
            0.5 + 0.5 * sin(time + treble)
          );

          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `;
    }

    function fragmentShader() {
      return `
        varying vec3 vColor;

        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      uniforms.mouse.value.set(mouse.x * 50, mouse.y * 50);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      analyser.getByteFrequencyData(dataArray);

      let bass = dataArray[0] / 255;
      if (bass > 0.8 && bass > lastLowPeak * 1.1) {
        lastLowPeak = bass;
        uniforms.time.value += 0.1;
      }

      uniforms.time.value += 0.05;
      uniforms.audioData.value = dataArray.map(d => d / 255);
      uniforms.sensitivity.value = sensitivity;

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
