<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Claymation Music Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
    </style>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <!-- ShaderPass for post-processing -->
    <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://threejs.org/examples/js/shaders/FXAAShader.js"></script>
    <script src="https://threejs.org/examples/js/shaders/ToonShader.js"></script>
</head>
<body>
<script>
    // Scene Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a1a);

    // Camera Setup
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 35;

    // Renderer Setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Post-processing for Toon Shading
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(new THREE.RenderPass(scene, camera));

    const effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
    effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
    composer.addPass(effectFXAA);

    // Controls (Optional)
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    hemiLight.position.set(0, 20, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(-5, 10, 5);
    scene.add(dirLight);

    // Clay Material Function
    function createClayMaterial(color) {
        const material = new THREE.MeshStandardMaterial({
            color: color,
            roughness: 0.9,
            metalness: 0.1
        });

        // Add procedural noise texture to simulate clay imperfections
        const noiseTexture = new THREE.TextureLoader().load('https://i.imgur.com/Uf4jK95.png');
        noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping;
        noiseTexture.repeat.set(2, 2);
        material.bumpMap = noiseTexture;
        material.bumpScale = 0.05;

        return material;
    }

    // Create Shapes with Clay Material
    const shapes = [];
    const geometries = [
        new THREE.SphereGeometry(1, 32, 32),
        new THREE.BoxGeometry(1.5, 1.5, 1.5),
        new THREE.ConeGeometry(1, 2, 32),
        new THREE.DodecahedronGeometry(1),
        new THREE.TorusGeometry(1, 0.4, 16, 100)
    ];

    for (let i = 0; i < 40; i++) {
        const geometry = geometries[i % geometries.length];
        const color = new THREE.Color(`hsl(${(i / 40) * 360}, 100%, 70%)`);
        const material = createClayMaterial(color);

        const shape = new THREE.Mesh(geometry, material);
        shape.position.x = (Math.random() - 0.5) * 50;
        shape.position.y = (Math.random() - 0.5) * 40;
        shape.position.z = (Math.random() - 0.5) * 30;
        shape.scale.setScalar(0.7 + Math.random() * 1.5);
        scene.add(shape);
        shapes.push(shape);
    }

    // Microphone Input
    let analyser;
    let dataArray;
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }).catch((err) => {
            console.error('Microphone access denied:', err);
        });
    }

    // Animation Variables
    let lastFrameTime = 0;
    const frameRate = 12; // Adjusted for stop-motion effect

    // Animate Function
    function animate(time) {
        requestAnimationFrame(animate);

        const delta = time - lastFrameTime;
        if (delta > 1000 / frameRate && analyser) {
            lastFrameTime = time;

            analyser.getByteFrequencyData(dataArray);

            shapes.forEach((shape, index) => {
                const dataIndex = Math.floor(index * (dataArray.length / shapes.length));
                const force = dataArray[dataIndex] / 256;
                const scale = 0.5 + Math.pow(force, 0.75) * 1.5;
                shape.scale.set(scale, scale, scale);

                // Imperfect Motion
                shape.position.y += Math.sin(time * 0.002 + index) * 0.05 + (Math.random() - 0.5) * 0.02;
                shape.position.z += Math.cos(time * 0.0015 + index) * 0.05 + (Math.random() - 0.5) * 0.02;
                shape.rotation.x += 0.02 + (Math.random() - 0.5) * 0.05;
                shape.rotation.y += 0.02 + (Math.random() - 0.5) * 0.05;
                shape.rotation.z += 0.01 + (Math.random() - 0.5) * 0.05;
            });

            // Subtle Camera Shake
            camera.position.x += (Math.random() - 0.5) * 0.02;
            camera.position.y += (Math.random() - 0.5) * 0.02;

            composer.render();
        }
    }
    animate(0);

    // Handle Window Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
    });
</script>
</body>
</html>
