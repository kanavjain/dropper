<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Artistically Dynamic Audio Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="visualizer"></canvas>

  <script>
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    let analyser, dataArray, audioContext;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const width = canvas.width;
    const height = canvas.height;

    let particles = [];
    const numParticles = 5000;  // High number for dense visuals
    let flowField = [];
    const flowFieldSize = 20;  // High resolution for detailed patterns
    let animationId;
    let hue = 0;
    let time = 0;

    let mouse = {
      x: null,
      y: null,
      isActive: false
    };

    // Audio Setup
    function setupAudio() {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(function (stream) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024;  // Increased for better frequency resolution

            source.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            init();
            animate();
          })
          .catch(function (err) {
            console.error('Microphone access denied:', err);
          });
      } else {
        alert('getUserMedia not supported in this browser.');
      }
    }

    setupAudio();

    // Particle Class
    class Particle {
      constructor(x, y) {
        this.x = x || Math.random() * width;
        this.y = y || Math.random() * height;
        this.speed = 0;
        this.velocity = { x: 0, y: 0 };
        this.size = Math.random() * 1.5 + 0.5;
        this.angle = 0;
        this.lastPos = { x: this.x, y: this.y };
      }

      update(flowField, audioLevel) {
        // Calculate position in flow field grid
        const col = Math.floor(this.x / flowFieldSize);
        const row = Math.floor(this.y / flowFieldSize);
        const index = col + row * Math.floor(width / flowFieldSize);

        // Get flow field angle and adjust with Perlin noise
        const angle = flowField[index];
        this.angle = angle;

        // Update velocity based on angle
        this.speed = audioLevel * 2 + 0.5;
        this.velocity.x = Math.cos(this.angle) * this.speed;
        this.velocity.y = Math.sin(this.angle) * this.speed;

        // Update position
        this.lastPos.x = this.x;
        this.lastPos.y = this.y;
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // Wrap around edges
        if (this.x > width) this.x = 0;
        if (this.x < 0) this.x = width;
        if (this.y > height) this.y = 0;
        if (this.y < 0) this.y = height;
      }

      draw() {
        ctx.beginPath();
        ctx.moveTo(this.lastPos.x, this.lastPos.y);
        ctx.lineTo(this.x, this.y);
        ctx.strokeStyle = `hsl(${(this.x / width) * 360 + time}, 100%, 50%)`;
        ctx.stroke();
      }
    }

    // Initialize particles and flow field
    function init() {
      particles = [];
      for (let i = 0; i < numParticles; i++) {
        particles.push(new Particle());
      }
      flowField = new Array(Math.floor(width / flowFieldSize) * Math.floor(height / flowFieldSize));
    }

    // Create Flow Field
    function createFlowField(audioData) {
      const cols = Math.floor(width / flowFieldSize);
      const rows = Math.floor(height / flowFieldSize);
      let index = 0;

      // Use Perlin noise for smooth, natural variations
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const noiseValue = noise.simplex3(x * 0.01, y * 0.01, time * 0.0005);
          const angle = noiseValue * Math.PI * 2;
          flowField[index] = angle;
          index++;
        }
      }
    }

    // Animate
    function animate() {
      animationId = requestAnimationFrame(animate);

      analyser.getByteFrequencyData(dataArray);
      const audioLevel = getAverageVolume(dataArray) / 255;

      // Clear canvas with lower opacity for motion trails
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, width, height);

      // Update time for Perlin noise
      time += 1;

      createFlowField(dataArray);

      particles.forEach(particle => {
        particle.update(flowField, audioLevel);
        particle.draw();
      });

      // Visual effects: optional glow effect
      // ctx.globalCompositeOperation = 'lighter';

      // Draw interactive elements
      if (mouse.isActive) {
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, 50, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fill();
      }
    }

    // Calculate average audio level
    function getAverageVolume(array) {
      let values = 0;
      for (let i = 0; i < array.length; i++) {
        values += array[i];
      }
      return values / array.length;
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      canvas.width = width = window.innerWidth;
      canvas.height = height = window.innerHeight;
      init();
    });

    // Mouse interaction
    canvas.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouse.isActive = true;
    });

    canvas.addEventListener('mousedown', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouse.isActive = true;

      // Add particles at mouse position
      for (let i = 0; i < 100; i++) {
        particles.push(new Particle(mouse.x, mouse.y));
      }
    });

    canvas.addEventListener('mouseup', () => {
      mouse.isActive = false;
    });

    canvas.addEventListener('mouseleave', () => {
      mouse.isActive = false;
    });

    // Touch interaction
    canvas.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;
      mouse.isActive = true;
    });

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      mouse.x = touch.clientX;
      mouse.y = touch.clientY;
      mouse.isActive = true;

      // Add particles at touch position
      for (let i = 0; i < 100; i++) {
        particles.push(new Particle(mouse.x, mouse.y));
      }
    });

    canvas.addEventListener('touchend', () => {
      mouse.isActive = false;
    });

    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
      cancelAnimationFrame(animationId);
    });

    // Perlin noise implementation (using Simplex Noise for better performance)
    const noise = new SimplexNoise();

    // Simplex Noise implementation
    // You can include a SimplexNoise library or implement it here
    // For brevity, let's assume SimplexNoise is included via a script tag or module

  </script>
  <!-- Include SimplexNoise library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/perlin-noise/0.1.0/perlin-noise.min.js"></script>
</body>
</html>
