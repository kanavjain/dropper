<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3D Pottery Wheel Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Include Three.js library from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Include OrbitControls for camera manipulation -->
  <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Set up the scene, camera, and renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 30, 50);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add orbit controls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Add lighting
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(0, 50, 50);
    scene.add(dirLight);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Create the pottery wheel
    const wheelGeometry = new THREE.CylinderGeometry(20, 20, 2, 32);
    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel.position.y = -1;
    scene.add(wheel);

    // Create the clay object
    const clayHeight = 20;
    const claySegments = 128; // Higher number for smoother clay
    const clayPoints = [];

    for (let i = 0; i <= clayHeight; i++) {
      const radius = 5; // Initial radius of the clay
      clayPoints.push(new THREE.Vector2(radius, i));
    }

    let clayGeometry = new THREE.LatheGeometry(clayPoints, claySegments);
    let clayMaterial = new THREE.MeshStandardMaterial({
      color: 0x8b4513,
      flatShading: true,
    });
    let clay = new THREE.Mesh(clayGeometry, clayMaterial);
    clay.position.y = 0;
    scene.add(clay);

    // Variables for interaction
    let isMouseDown = false;
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();

    // Event listeners
    renderer.domElement.addEventListener('mousedown', onMouseDown, false);
    renderer.domElement.addEventListener('mousemove', onMouseMove, false);
    renderer.domElement.addEventListener('mouseup', onMouseUp, false);

    function onMouseDown(event) {
      isMouseDown = true;
    }

    function onMouseMove(event) {
      if (isMouseDown) {
        // Normalize mouse coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        // Update the raycaster
        raycaster.setFromCamera(mouse, camera);

        // Check for intersections with the clay mesh
        const intersects = raycaster.intersectObject(clay);
        if (intersects.length > 0) {
          // Get the point of intersection
          const point = intersects[0].point;

          // Deform the clay geometry at the point of contact
          deformClay(point);
        }
      }
    }

    function onMouseUp(event) {
      isMouseDown = false;
    }

    function deformClay(point) {
      const position = clay.geometry.attributes.position;
      const vector = new THREE.Vector3();

      for (let i = 0; i < position.count; i++) {
        vector.fromBufferAttribute(position, i);
        const distance = vector.distanceTo(point);

        // If the vertex is close to the interaction point, move it
        if (distance < 2) {
          const effect = (2 - distance) / 2; // Soften the effect over distance
          const direction = vector.clone().sub(point).normalize();
          vector.addScaledVector(direction, -effect * 0.5);
          position.setXYZ(i, vector.x, vector.y, vector.z);
        }
      }

      position.needsUpdate = true;
      clay.geometry.computeVertexNormals();
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Rotate the clay to simulate spinning
      clay.rotation.y += 0.05;

      renderer.render(scene, camera);
    }

    animate();

    // Handle window resize
    window.addEventListener('resize', onWindowResize, false);

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
