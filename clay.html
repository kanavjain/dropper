<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Advanced Pottery Wheel Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; touch-action: none; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            z-index: 1;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #ui button, #ui select {
            margin-top: 5px;
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        #colorPicker {
            margin-top: 5px;
            padding: 0;
            width: 100%;
            height: 30px;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="ui">
    <p>Select Tool:</p>
    <select id="toolSelector">
        <option value="push">Push</option>
        <option value="pull">Pull</option>
        <option value="smooth">Smooth</option>
    </select>
    <br>
    <p>Clay Color:</p>
    <input type="color" id="colorPicker" value="#d2a679">
    <br>
    <button id="resetButton">Reset Clay</button>
    <button id="undoButton">Undo</button>
    <button id="redoButton">Redo</button>
    <br>
    <button id="saveImageButton">Save Image</button>
    <button id="exportModelButton">Export Model (OBJ)</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/exporters/OBJExporter.js"></script>
<script>
    // Basic Three.js setup
    let scene, camera, renderer, controls;
    let potteryMesh, wheelMesh;
    let isInteracting = false;
    let previousY = 0;
    let profilePoints = [];
    const maxRadius = 5;
    const minRadius = 0.5;
    const height = 12;
    const segments = 100;
    const textureLoader = new THREE.TextureLoader();
    let tool = 'push';
    const actionHistory = [];
    let historyIndex = -1;

    init();
    animate();

    function init() {
        // Scene and Camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        // Position the camera to simulate the potter's perspective
        camera.position.set(0, 8, 10);
        camera.lookAt(0, 5, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Pottery Wheel
        const wheelGeometry = new THREE.CylinderGeometry(6, 6, 1, 32);
        const wheelTexture = textureLoader.load('https://i.imgur.com/3d8c5bx.jpg');
        const wheelMaterial = new THREE.MeshStandardMaterial({ map: wheelTexture });
        wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheelMesh.position.y = 0.5;
        wheelMesh.receiveShadow = true;
        scene.add(wheelMesh);

        // Clay
        createClay();

        // Ground Plane
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = 0;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);

        // Unified Pointer Events
        const domElement = renderer.domElement;
        domElement.addEventListener('pointerdown', onPointerDown, false);
        domElement.addEventListener('pointerup', onPointerUp, false);
        domElement.addEventListener('pointermove', onPointerMove, false);
        domElement.addEventListener('pointercancel', onPointerUp, false);
        domElement.addEventListener('pointerout', onPointerUp, false);
        domElement.addEventListener('pointerleave', onPointerUp, false);

        // Disable context menu on long press
        domElement.addEventListener('contextmenu', event => event.preventDefault());

        // UI Elements
        document.getElementById('resetButton').addEventListener('click', resetClay);
        document.getElementById('undoButton').addEventListener('click', undoAction);
        document.getElementById('redoButton').addEventListener('click', redoAction);
        document.getElementById('saveImageButton').addEventListener('click', savePotteryImage);
        document.getElementById('exportModelButton').addEventListener('click', exportPotteryModel);

        const toolSelector = document.getElementById('toolSelector');
        toolSelector.addEventListener('change', event => {
            tool = event.target.value;
        });

        const colorPicker = document.getElementById('colorPicker');
        colorPicker.addEventListener('input', event => {
            updateClayMaterial(event.target.value);
        });
    }

    function createClay() {
        // Create initial profile curve for the clay
        profilePoints = [];
        const step = height / segments;
        for (let i = 0; i <= segments; i++) {
            const y = i * step;
            const radius = maxRadius;
            profilePoints.push(new THREE.Vector2(radius, y));
        }

        saveAction(); // Save initial state
        updateClayGeometry();
    }

    function updateClayGeometry() {
        // Remove existing mesh if any
        if (potteryMesh) {
            scene.remove(potteryMesh);
            potteryMesh.geometry.dispose();
            potteryMesh.material.dispose();
        }

        // Create LatheGeometry from profile curve
        const clayGeometry = new THREE.LatheGeometry(profilePoints, 200);
        clayGeometry.computeVertexNormals();

        // Clay Material with Color
        const clayMaterial = new THREE.MeshStandardMaterial({
            color: document.getElementById('colorPicker').value,
            side: THREE.DoubleSide,
            flatShading: false,
        });

        potteryMesh = new THREE.Mesh(clayGeometry, clayMaterial);
        potteryMesh.position.y = 0;
        potteryMesh.castShadow = true;
        potteryMesh.receiveShadow = true;
        scene.add(potteryMesh);
    }

    function updateClayMaterial(color) {
        if (potteryMesh) {
            potteryMesh.material.color.set(color);
        }
    }

    function onPointerDown(event) {
        isInteracting = true;
        previousY = event.clientY || event.touches[0].clientY;
        // Lock pointer for better mobile experience
        event.target.setPointerCapture(event.pointerId);
    }

    function onPointerUp(event) {
        if (isInteracting) {
            saveAction(); // Save state after interaction
        }
        isInteracting = false;
        event.target.releasePointerCapture(event.pointerId);
    }

    function onPointerMove(event) {
        if (isInteracting) {
            const currentY = event.clientY || (event.touches && event.touches[0].clientY);
            const deltaY = currentY - previousY;
            previousY = currentY;

            // Map pointer movement to clay deformation
            deformClay(deltaY, currentY);
        }
    }

    function deformClay(deltaY, pointerY) {
        const rect = renderer.domElement.getBoundingClientRect();
        const normalizedY = ((pointerY - rect.top) / rect.height) * height;

        const influenceRadius = 1.5; // How wide the influence of the deformation is
        let deformationStrength = deltaY * 0.05;

        // Adjust deformation strength based on tool
        if (tool === 'pull') {
            deformationStrength = -deformationStrength;
        } else if (tool === 'smooth') {
            deformationStrength *= 0.2; // Less aggressive smoothing
        }

        // Deform the profile points
        profilePoints.forEach(point => {
            const distance = Math.abs(point.y - normalizedY);
            if (distance < influenceRadius) {
                let deformation = deformationStrength * (1 - distance / influenceRadius);

                if (tool === 'smooth') {
                    // Smooth deformation averages the radius with neighboring points
                    const index = profilePoints.indexOf(point);
                    const prevRadius = profilePoints[Math.max(0, index - 1)].x;
                    const nextRadius = profilePoints[Math.min(profilePoints.length - 1, index + 1)].x;
                    const averageRadius = (prevRadius + nextRadius) / 2;
                    deformation = (averageRadius - point.x) * 0.5;
                }

                point.x += deformation;

                // Clamp the radius between minRadius and maxRadius
                point.x = THREE.MathUtils.clamp(point.x, minRadius, maxRadius);
            }
        });

        // Update the clay geometry
        updateClayGeometry();
    }

    function resetClay() {
        createClay();
    }

    function savePotteryImage() {
        renderer.render(scene, camera); // Ensure the latest frame is rendered
        const dataURL = renderer.domElement.toDataURL('image/png');

        // Create a temporary link to trigger the download
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'my_pottery.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function exportPotteryModel() {
        const exporter = new THREE.OBJExporter();
        const objString = exporter.parse(potteryMesh);

        // Create a blob and trigger download
        const blob = new Blob([objString], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'my_pottery.obj';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function saveAction() {
        // Remove any redo history
        actionHistory.splice(historyIndex + 1);
        // Save a deep copy of the profilePoints
        actionHistory.push(JSON.parse(JSON.stringify(profilePoints)));
        historyIndex++;
    }

    function undoAction() {
        if (historyIndex > 0) {
            historyIndex--;
            profilePoints = JSON.parse(JSON.stringify(actionHistory[historyIndex]));
            updateClayGeometry();
        }
    }

    function redoAction() {
        if (historyIndex < actionHistory.length - 1) {
            historyIndex++;
            profilePoints = JSON.parse(JSON.stringify(actionHistory[historyIndex]));
            updateClayGeometry();
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        // Rotate the wheel and clay
        wheelMesh.rotation.y += 0.02;
        potteryMesh.rotation.y += 0.02;

        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
