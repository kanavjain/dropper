<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Realistic Pottery Wheel Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; touch-action: none; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            z-index: 1;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s;
        }
        #ui button {
            margin-top: 5px;
            padding: 5px 10px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="ui">
    <button id="resetButton">Reset Clay</button>
    <button id="saveButton">Save Pottery</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.18.0/dist/cannon-es.js"></script>
<script>
    // Basic Three.js setup
    let scene, camera, renderer;
    let potteryMesh, wheelMesh;
    let isInteracting = false;
    let previousTouches = [];
    const maxRadius = 5;
    const minRadius = 0.5;
    const height = 12;
    const segments = 50; // Reduced for performance
    const textureLoader = new THREE.TextureLoader();
    let world, physicsMaterial, clayBody;
    const clock = new THREE.Clock();

    init();
    animate();

    function init() {
        // Scene and Camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );

        // Position the camera to simulate the potter's perspective
        camera.position.set(0, 8, 10);
        camera.lookAt(0, 5, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Pottery Wheel
        const wheelGeometry = new THREE.CylinderGeometry(6, 6, 1, 32);
        const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
        wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheelMesh.position.y = 0.5;
        wheelMesh.receiveShadow = true;
        scene.add(wheelMesh);

        // Ground Plane
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = 0;
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        // Physics World
        world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        physicsMaterial = new CANNON.Material();

        // Clay
        createClay();

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);

        // Unified Pointer Events
        const domElement = renderer.domElement;
        domElement.addEventListener('pointerdown', onPointerDown, false);
        domElement.addEventListener('pointerup', onPointerUp, false);
        domElement.addEventListener('pointermove', onPointerMove, false);
        domElement.addEventListener('pointercancel', onPointerUp, false);
        domElement.addEventListener('pointerout', onPointerUp, false);
        domElement.addEventListener('pointerleave', onPointerUp, false);

        // Disable context menu on long press
        domElement.addEventListener('contextmenu', event => event.preventDefault());

        // UI Buttons
        const uiElement = document.getElementById('ui');
        document.getElementById('resetButton').addEventListener('click', resetClay);
        document.getElementById('saveButton').addEventListener('click', savePottery);

        // Hide UI after inactivity
        let uiTimeout;
        function resetUITimeout() {
            clearTimeout(uiTimeout);
            uiElement.style.opacity = 1;
            uiTimeout = setTimeout(() => {
                uiElement.style.opacity = 0;
            }, 3000);
        }
        resetUITimeout();
        document.addEventListener('pointermove', resetUITimeout);
        document.addEventListener('pointerdown', resetUITimeout);
    }

    function createClay() {
        // Remove existing clay body from physics world
        if (clayBody) {
            world.removeBody(clayBody);
        }

        // Create initial profile curve for the clay
        const profilePoints = [];
        const step = height / segments;
        for (let i = 0; i <= segments; i++) {
            const y = i * step;
            const radius = maxRadius;
            profilePoints.push(new THREE.Vector2(radius, y));
        }

        // Create LatheGeometry from profile curve
        const clayGeometry = new THREE.LatheGeometry(profilePoints, 100);
        clayGeometry.computeVertexNormals();

        // Clay Material with Shaders for Wet Look
        const clayMaterial = new THREE.MeshStandardMaterial({
            color: 0xd2a679,
            roughness: 0.5,
            metalness: 0.1,
        });

        // Remove existing mesh if any
        if (potteryMesh) {
            scene.remove(potteryMesh);
            potteryMesh.geometry.dispose();
            potteryMesh.material.dispose();
        }

        potteryMesh = new THREE.Mesh(clayGeometry, clayMaterial);
        potteryMesh.position.y = 0;
        potteryMesh.castShadow = true;
        potteryMesh.receiveShadow = true;
        scene.add(potteryMesh);

        // Create physics body for the clay
        const clayShape = createPhysicsShapeFromGeometry(clayGeometry);
        clayBody = new CANNON.Body({ mass: 0 });
        clayBody.addShape(clayShape);
        clayBody.position.set(potteryMesh.position.x, potteryMesh.position.y, potteryMesh.position.z);
        world.addBody(clayBody);
    }

    function createPhysicsShapeFromGeometry(geometry) {
        // Approximate the geometry with a convex hull for physics
        const vertices = geometry.attributes.position.array;
        const points = [];
        for (let i = 0; i < vertices.length; i += 3) {
            points.push(new CANNON.Vec3(vertices[i], vertices[i + 1], vertices[i + 2]));
        }
        return new CANNON.ConvexPolyhedron({ vertices: points });
    }

    function onPointerDown(event) {
        isInteracting = true;
        previousTouches = [getTouchPosition(event)];
        event.target.setPointerCapture(event.pointerId);

        // Haptic Feedback
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
    }

    function onPointerUp(event) {
        isInteracting = false;
        previousTouches = [];
        event.target.releasePointerCapture(event.pointerId);
    }

    function onPointerMove(event) {
        if (isInteracting) {
            const currentTouches = [getTouchPosition(event)];
            if (event.touches && event.touches.length > 1) {
                currentTouches.push(getTouchPosition(event, 1));
            }

            if (previousTouches.length === currentTouches.length) {
                if (currentTouches.length === 1) {
                    // Single touch deformation
                    const deltaY = currentTouches[0].y - previousTouches[0].y;
                    deformClay(deltaY, currentTouches[0].y);
                } else if (currentTouches.length === 2) {
                    // Multi-touch pinch gesture
                    const prevDistance = getDistance(previousTouches[0], previousTouches[1]);
                    const currDistance = getDistance(currentTouches[0], currentTouches[1]);
                    const scale = currDistance / prevDistance;
                    deformClayWithPinch(scale, currentTouches);
                }

                // Haptic Feedback
                if (navigator.vibrate) {
                    const intensity = Math.min(Math.abs(currentTouches[0].y - previousTouches[0].y), 100);
                    navigator.vibrate(intensity);
                }
            }

            previousTouches = currentTouches;
        }
    }

    function getTouchPosition(event, index = 0) {
        if (event.touches && event.touches.length > index) {
            return { x: event.touches[index].clientX, y: event.touches[index].clientY };
        } else {
            return { x: event.clientX, y: event.clientY };
        }
    }

    function getDistance(p1, p2) {
        return Math.hypot(p1.x - p2.x, p1.y - p2.y);
    }

    function deformClay(deltaY, pointerY) {
        const rect = renderer.domElement.getBoundingClientRect();
        const normalizedY = ((pointerY - rect.top) / rect.height) * height;

        const influenceRadius = 1.5; // How wide the influence of the deformation is
        const deformationStrength = deltaY * 0.05;

        // Deform the clay geometry
        const positions = potteryMesh.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            const distance = Math.abs(y - normalizedY);
            if (distance < influenceRadius) {
                const factor = deformationStrength * (1 - distance / influenceRadius);
                let x = positions.getX(i);
                let z = positions.getZ(i);
                const radius = Math.sqrt(x * x + z * z);
                const angle = Math.atan2(z, x);
                let newRadius = radius + factor;
                newRadius = THREE.MathUtils.clamp(newRadius, minRadius, maxRadius);
                x = newRadius * Math.cos(angle);
                z = newRadius * Math.sin(angle);
                positions.setX(i, x);
                positions.setZ(i, z);
            }
        }

        positions.needsUpdate = true;
        potteryMesh.geometry.computeVertexNormals();
    }

    function deformClayWithPinch(scale, touches) {
        const centerY = (touches[0].y + touches[1].y) / 2;
        const rect = renderer.domElement.getBoundingClientRect();
        const normalizedY = ((centerY - rect.top) / rect.height) * height;

        const influenceRadius = 3;
        const deformationStrength = (scale - 1) * 10;

        // Deform the clay geometry
        const positions = potteryMesh.geometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i);
            const distance = Math.abs(y - normalizedY);
            if (distance < influenceRadius) {
                const factor = deformationStrength * (1 - distance / influenceRadius);
                let x = positions.getX(i);
                let z = positions.getZ(i);
                const radius = Math.sqrt(x * x + z * z);
                const angle = Math.atan2(z, x);
                let newRadius = radius + factor;
                newRadius = THREE.MathUtils.clamp(newRadius, minRadius, maxRadius);
                x = newRadius * Math.cos(angle);
                z = newRadius * Math.sin(angle);
                positions.setX(i, x);
                positions.setZ(i, z);
            }
        }

        positions.needsUpdate = true;
        potteryMesh.geometry.computeVertexNormals();
    }

    function resetClay() {
        createClay();
    }

    function savePottery() {
        renderer.render(scene, camera); // Ensure the latest frame is rendered
        const dataURL = renderer.domElement.toDataURL('image/png');

        // Create a temporary link to trigger the download
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = 'my_pottery.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        world.step(delta);

        // Rotate the wheel and clay
        const rotationSpeed = 0.02;
        wheelMesh.rotation.y += rotationSpeed;
        potteryMesh.rotation.y += rotationSpeed;

        // Enhanced Visual Effects: Motion Blur Simulation
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
