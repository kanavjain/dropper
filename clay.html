<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced WebGL Audio Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      color: white;
      font-family: Arial, sans-serif;
    }
    #controls label {
      margin-right: 10px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
  <canvas id="visualizer"></canvas>
  <div id="controls">
    <label>Color</label>
    <input type="color" id="colorPicker" value="#ffffff">
    <label>Sensitivity</label>
    <input type="range" id="sensitivity" min="0.1" max="5" step="0.1" value="1">
  </div>

  <script>
    let scene, camera, renderer, particles, analyser, dataArray, uniforms;
    const canvas = document.getElementById('visualizer');
    const colorPicker = document.getElementById('colorPicker');
    const sensitivitySlider = document.getElementById('sensitivity');
    const mouse = { x: 0, y: 0 };
    let sensitivity = 1;

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      // Renderer setup
      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Audio setup
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        // Create particle system
        createParticles();

        // Start animation loop
        animate();
      }).catch(err => {
        console.error('Audio access denied:', err);
      });

      // Handle resize
      window.addEventListener('resize', onResize);
      document.addEventListener('mousemove', onMouseMove);

      // Update sensitivity and color
      sensitivitySlider.addEventListener('input', () => {
        sensitivity = parseFloat(sensitivitySlider.value);
      });
      colorPicker.addEventListener('input', () => {
        uniforms.color.value.set(colorPicker.value);
      });
    }

    function createParticles() {
      const particleCount = 15000; // Increase particle density
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        velocities[i * 3] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

      uniforms = {
        time: { value: 0 },
        mouse: { value: new THREE.Vector2() },
        audioData: { value: new Float32Array(128) },
        color: { value: new THREE.Color(colorPicker.value) },
        sensitivity: { value: sensitivity }
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader(),
        fragmentShader: fragmentShader(),
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function vertexShader() {
      return `
        uniform float time;
        uniform vec2 mouse;
        uniform float audioData[128];
        uniform float sensitivity;

        attribute vec3 velocity;
        varying vec3 vColor;

        void main() {
          vec3 newPosition = position + velocity * time * 0.1;

          // React to audio data, clustering based on bass frequencies
          float audioAmplitude = audioData[int(position.x * 0.5 + 64.0)] * sensitivity;
          
          // Amplify audio effects for more obvious reaction
          audioAmplitude *= 2.5; // Increase audio influence to make it more obvious

          newPosition.x += sin(time + position.x) * 0.2 * audioAmplitude;
          newPosition.y += cos(time + position.y) * 0.2 * audioAmplitude;

          // Increase particle size and brightness for stronger beats
          if (audioAmplitude > 0.8) {
            gl_PointSize = 5.0 + audioAmplitude * 8.0;
            vColor = vec3(1.0, 1.0, 1.0); // Bright burst on beats
          } else {
            gl_PointSize = 2.0 + audioAmplitude * 5.0;
            // Color based on frequency, shifting between blue and purple
            vColor = vec3(0.5 + 0.5 * sin(position.x * 0.1), 0.5 + 0.5 * cos(position.y * 0.1), 1.0);
          }

          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
        }
      `;
    }

    function fragmentShader() {
      return `
        varying vec3 vColor;

        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      uniforms.mouse.value.set(mouse.x * 50, mouse.y * 50);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update uniforms
      analyser.getByteFrequencyData(dataArray);
      uniforms.time.value += 0.05;
      uniforms.audioData.value = dataArray.map(d => d / 255);
      uniforms.sensitivity.value = sensitivity;

      // Render the scene
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
