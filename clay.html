<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Audio Visualizer</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    canvas {
      display: block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body>
  <canvas id="visualizer"></canvas>

  <script>
    let scene, camera, renderer, particles, analyser, dataArray, uniforms;
    const canvas = document.getElementById('visualizer');
    const mouse = { x: 0, y: 0 };

    function init() {
      // Scene setup
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      // Renderer setup
      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Audio setup
      navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        // Create particle system
        createParticles();

        // Start animation loop
        animate();
      }).catch(err => {
        console.error('Audio access denied:', err);
      });

      // Handle resize
      window.addEventListener('resize', onResize);
      document.addEventListener('mousemove', onMouseMove);
    }

    function createParticles() {
      const particleCount = 10000;
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        velocities[i * 3] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
        velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

      uniforms = {
        time: { value: 0 },
        mouse: { value: new THREE.Vector2() },
        audioData: { value: new Float32Array(128) },
        color: { value: new THREE.Color(0xffffff) }
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader(),
        fragmentShader: fragmentShader(),
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    function vertexShader() {
      return `
        uniform float time;
        uniform vec2 mouse;
        uniform float audioData[128];

        attribute vec3 velocity;
        varying vec3 vColor;

        void main() {
          vec3 newPosition = position + velocity * time * 0.1;

          // Basic animation without audio for debugging
          newPosition.x += sin(time + position.x) * 0.2;
          newPosition.y += cos(time + position.y) * 0.2;

          // Color based on distance from mouse
          float dist = distance(mouse, vec2(newPosition.x, newPosition.y));
          vColor = vec3(0.5 + 0.5 * sin(dist * 0.1), 0.5 + 0.5 * cos(dist * 0.1), 1.0);

          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
          gl_PointSize = 3.0;
        }
      `;
    }

    function fragmentShader() {
      return `
        varying vec3 vColor;

        void main() {
          gl_FragColor = vec4(vColor, 1.0);
        }
      `;
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      uniforms.mouse.value.set(mouse.x * 50, mouse.y * 50);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Update uniforms
      analyser.getByteFrequencyData(dataArray);
      uniforms.time.value += 0.05;
      uniforms.audioData.value = dataArray.map(d => d / 255);

      // Render the scene
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
