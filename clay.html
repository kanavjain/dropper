<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Virtual Pottery Wheel</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { background-color: #f0f0f0; display: block; margin: 0 auto; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Set canvas to full window size
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    let rotationOffset = 0;
    const rotationSpeed = 0.05;

    const numPoints = 200;
    const profile = [];
    const maxRadius = canvasWidth / 6;
    const centerY = canvasHeight / 2;
    const centerX = canvasWidth / 2;

    // Initialize the clay profile as a cylinder
    for (let i = 0; i < numPoints; i++) {
      profile[i] = maxRadius;
    }

    // Event handlers for mouse interaction
    let isMouseDown = false;
    let lastMouseY = 0;
    let lastMouseX = 0;

    canvas.addEventListener('mousedown', function(e) {
      isMouseDown = true;
      const rect = canvas.getBoundingClientRect();
      lastMouseX = e.clientX - rect.left;
      lastMouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousemove', function(e) {
      if (isMouseDown) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const dx = mouseX - centerX;
        const dy = mouseY - lastMouseY;

        const yIndex = Math.floor((mouseY / canvasHeight) * numPoints);
        if (yIndex >= 0 && yIndex < numPoints) {
          const deltaRadius = dx / 5;
          profile[yIndex] += deltaRadius;
          if (profile[yIndex] > maxRadius) profile[yIndex] = maxRadius;
          if (profile[yIndex] < 0) profile[yIndex] = 0;
        }

        lastMouseX = mouseX;
        lastMouseY = mouseY;
      }
    });

    canvas.addEventListener('mouseup', function(e) {
      isMouseDown = false;
    });

    canvas.addEventListener('mouseleave', function(e) {
      isMouseDown = false;
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      rotationOffset += rotationSpeed;

      ctx.clearRect(0, 0, canvasWidth, canvasHeight);

      const angles = [];
      const numAngles = 30; // Number of profiles to draw per frame
      for (let i = 0; i < numAngles; i++) {
        angles.push((i / numAngles) * Math.PI * 2);
      }

      for (let i = 0; i < angles.length; i++) {
        const angle = angles[i] + rotationOffset;
        const cosAngle = Math.cos(angle);
        const shade = (cosAngle + 1) / 2; // Value between 0 and 1

        ctx.beginPath();
        ctx.strokeStyle = `rgba(150, 100, 50, ${shade})`;
        ctx.lineWidth = 2;

        for (let j = 0; j < numPoints - 1; j++) {
          const y1 = (j / numPoints) * canvasHeight;
          const y2 = ((j + 1) / numPoints) * canvasHeight;

          const radius1 = profile[j];
          const radius2 = profile[j + 1];

          const x1 = centerX + radius1 * Math.cos(angle);
          const x2 = centerX + radius2 * Math.cos(angle);

          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
        }

        ctx.stroke();
      }
    }

    animate();
  </script>
</body>
</html>
