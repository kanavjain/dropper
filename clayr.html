<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Pottery Wheel Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; touch-action: none; }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: Arial, sans-serif;
            z-index: 1;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #ui button { margin: 5px; padding: 5px 10px; font-size: 14px; cursor: pointer; }
        #message {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
    </style>
</head>
<body>

<div id="ui">
    <button id="resetButton">Reset Clay</button>
    <button id="fireButton">Fire Pottery</button>
    <button id="glazeButton">Glaze Pottery</button>
    <button id="saveButton">Save/Export Pottery</button>
</div>
<div id="message">Move your device to scan the area...</div>

<!-- Import Three.js from cdnjs -->
<script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/three.module.min.js';
    import { GLTFLoader } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/examples/jsm/loaders/GLTFLoader.js';
    import { OrbitControls } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/examples/jsm/postprocessing/RenderPass.js';
    import { BloomPass } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/examples/jsm/postprocessing/BloomPass.js';

    let scene, camera, renderer, potteryMesh, wheelMesh, reticle, hitTestSource, isPlaced = false, isInteracting = false;
    let composer;
    const maxRadius = 0.15, minRadius = 0.02, height = 0.3, segments = 200;
    let currentTool = 'smooth', isFired = false, isGlazed = false;

    function init() {
        setupScene();
        setupRenderer();
        setupComposer();
        setupUI();
        animate();
    }

    function setupScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 20);
        camera.position.set(0, 1, 2);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        reticle = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.06, 32).rotateX(-Math.PI / 2), new THREE.MeshBasicMaterial({ color: 0xffffff }));
        reticle.visible = false;
        scene.add(reticle);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.update();

        window.addEventListener('resize', onWindowResize);
        setupTouchEvents();
    }

    function setupRenderer() {
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(THREE.ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
    }

    function setupComposer() {
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        const bloomPass = new BloomPass(1.25);  // Bloom effect
        composer.addPass(renderPass);
        composer.addPass(bloomPass);
    }

    function setupUI() {
        const uiElement = document.getElementById('ui');
        document.getElementById('resetButton').addEventListener('click', resetClay);
        document.getElementById('fireButton').addEventListener('click', firePottery);
        document.getElementById('glazeButton').addEventListener('click', glazePottery);
        document.getElementById('saveButton').addEventListener('click', savePottery);

        let uiTimeout;
        function resetUITimeout() {
            clearTimeout(uiTimeout);
            uiElement.style.opacity = 1;
            uiTimeout = setTimeout(() => uiElement.style.opacity = 0, 3000);
        }
        document.addEventListener('pointermove', resetUITimeout);
        document.addEventListener('pointerdown', resetUITimeout);
    }

    function setupTouchEvents() {
        const domElement = renderer.domElement;
        domElement.addEventListener('pointerdown', () => isInteracting = true);
        domElement.addEventListener('pointerup', () => isInteracting = false);
        domElement.addEventListener('pointermove', onPointerMove);
        domElement.addEventListener('contextmenu', event => event.preventDefault());
    }

    function createPottery() {
        isFired = false;
        isGlazed = false;

        const profilePoints = [];
        const step = height / segments;
        for (let i = 0; i <= segments; i++) {
            profilePoints.push(new THREE.Vector2(maxRadius, i * step));
        }

        const clayGeometry = new THREE.LatheGeometry(profilePoints, 200);
        clayGeometry.computeVertexNormals();
        const clayMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, roughness: 0.9, metalness: 0.1,
        });

        potteryMesh = new THREE.Mesh(clayGeometry, clayMaterial);
        potteryMesh.castShadow = true;
        potteryMesh.receiveShadow = true;
        potteryMesh.rotation.y = Math.PI;

        const wheelGeometry = new THREE.CylinderGeometry(maxRadius * 2, maxRadius * 2, 0.02, 64);
        const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
        wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheelMesh.receiveShadow = true;

        const group = new THREE.Group();
        group.add(wheelMesh);
        group.add(potteryMesh);
        wheelMesh.position.y = 0;
        potteryMesh.position.y = 0.02;
        scene.add(group);
        group.position.copy(reticle.position);
        group.rotation.copy(reticle.rotation);
    }

    function onPointerMove(event) {
        if (isInteracting && isPlaced && !isFired) {
            const touch = event.changedTouches ? event.changedTouches[0] : event;
            const x = (touch.clientX / window.innerWidth) * 2 - 1;
            const y = -(touch.clientY / window.innerHeight) * 2 + 1;
            const pointer = new THREE.Vector2(x, y);

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObject(potteryMesh);
            if (intersects.length > 0) deformClay(intersects[0].point);
        }
    }

    function deformClay(point) {
        const normalizedY = point.y - potteryMesh.parent.position.y;
        const pointRadius = Math.sqrt(point.x * point.x + point.z * point.z);

        const influenceRadius = 0.01;
        const deformationStrength = 0.001;
        const positions = potteryMesh.geometry.attributes.position;

        for (let i = 0; i < positions.count; i++) {
            const y = positions.getY(i), x = positions.getX(i), z = positions.getZ(i);
            const vertexRadius = Math.sqrt(x * x + z * z), angle = Math.atan2(z, x);
            const distanceY = Math.abs(y - normalizedY);
            const distanceX = Math.abs(vertexRadius - pointRadius);
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

            if (distance < influenceRadius) {
                const factor = deformationStrength * (1 - distance / influenceRadius);
                let newRadius = vertexRadius + (currentTool === 'smooth' ? factor : -Math.abs(factor));
                newRadius = THREE.MathUtils.clamp(newRadius, minRadius, maxRadius);
                positions.setIt seems I was cut off while providing the refactored code. Here's the remaining part along with everything implemented:

```javascript
    newRadius = THREE.MathUtils.clamp(newRadius, minRadius, maxRadius);
    const newX = newRadius * Math.cos(angle);
    const newZ = newRadius * Math.sin(angle);
    positions.setXYZ(i, newX, y, newZ);
    }
  }
  positions.needsUpdate = true;
  potteryMesh.geometry.computeVertexNormals();
}

function resetClay() {
  if (potteryMesh) scene.remove(potteryMesh.parent);
  createPottery();
}

function firePottery() {
  if (isFired || !isPlaced) return;
  isFired = true;
  potteryMesh.material.color.setHex(0xCD853F);
  potteryMesh.material.roughness = 0.5;
  potteryMesh.material.metalness = 0.2;
  potteryMesh.material.needsUpdate = true;
}

function glazePottery() {
  if (!isFired || isGlazed || !isPlaced) return;
  isGlazed = true;
  potteryMesh.material.color.setHex(0xFFD700);
  potteryMesh.material.roughness = 0.1;
  potteryMesh.material.metalness = 0.5;
  potteryMesh.material.needsUpdate = true;
}

function savePottery() {
  if (!isPlaced) return;
  const exporter = new THREE.OBJExporter();
  const objData = exporter.parse(potteryMesh);
  const blob = new Blob([objData], { type: 'text/plain' });
  const link = document.createElement('a');
  link.download = 'pottery.obj';
  link.href = URL.createObjectURL(blob);
  link.click();
}

function animate() {
  composer.setAnimationLoop(render);
}

function render() {
  if (isPlaced) {
    const rotationSpeed = 0.02;
    wheelMesh.rotation.y += rotationSpeed;
    if (!isFired) potteryMesh.rotation.y += rotationSpeed;
    document.getElementById('message').style.display = 'none';
  }
  composer.render();
}

renderer.domElement.addEventListener('click', () => {
  if (!isPlaced && reticle.visible) {
    isPlaced = true;
    createPottery();
    document.getElementById('message').style.display = 'none';
  }
});

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Initialize the AR simulation
init();
</script>

</body>
</html>
