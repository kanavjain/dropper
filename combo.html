<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Immersive Music Visualizer</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tensorflow/tf.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x0a0a0a, 1);
        document.body.appendChild(renderer.domElement);

        // Camera initial position
        camera.position.set(0, 10, 30);
        camera.lookAt(0, 0, 0);

        // Adding procedural geometry - dynamic fractal elements
        const fractalMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vPos;
                void main() {
                    vPos = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vPos;
                uniform float u_time;
                uniform vec3 u_color;
                void main() {
                    float intensity = length(vPos) * 0.1;
                    float glow = 0.5 + 0.5 * sin(u_time + length(vPos));
                    vec3 color = u_color * glow * intensity;
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            uniforms: {
                u_time: { value: 0.0 },
                u_color: { value: new THREE.Color(0x00ffcc) },
            },
            transparent: true,
            blending: THREE.AdditiveBlending
        });

        const fractalGeometry = new THREE.IcosahedronGeometry(10, 5);
        const fractalMesh = new THREE.Mesh(fractalGeometry, fractalMaterial);
        scene.add(fractalMesh);

        // Adding lighting for a modern neon look
        const light = new THREE.PointLight(0xff77cc, 5, 200);
        light.position.set(20, 30, 20);
        scene.add(light);

        const directionalLight = new THREE.DirectionalLight(0x00ffcc, 1);
        directionalLight.position.set(-10, 50, -10);
        scene.add(directionalLight);

        // Environment particles - adding depth to the scene
        const particleCount = 8000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3 + 0] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particlesMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, opacity: 0.8, transparent: true });
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // Adding a torus knot for the surreal tunnel effect
        const torusGeometry = new THREE.TorusKnotGeometry(10, 3, 200, 32);
        const torusMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0affef, 
            emissive: 0x001133, 
            emissiveIntensity: 0.7, 
            metalness: 0.9, 
            roughness: 0.3 
        });
        const torusKnot = new THREE.Mesh(torusGeometry, torusMaterial);
        scene.add(torusKnot);

        // Adding additional point lights for a cyberpunk effect
        const pointLight1 = new THREE.PointLight(0xff0099, 2, 100);
        pointLight1.position.set(20, 30, 20);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x00ffff, 2, 100);
        pointLight2.position.set(-20, -30, 20);
        scene.add(pointLight2);

        // Setup audio with modern Web Audio API
        let analyser;
        let dataArray;
        navigator.mediaDevices.getUserMedia({ audio: true }).then(function (stream) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioSource = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 512;
            audioSource.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }).catch(function (err) {
            console.error('Error accessing microphone: ', err);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                let avgFreq = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                fractalMaterial.uniforms.u_time.value += 0.05;
                fractalMaterial.uniforms.u_color.value.setHSL(avgFreq / 255, 0.8, 0.5);

                // Update torus knot scale and rotation based on audio
                torusKnot.scale.set(1 + avgFreq / 255, 1 + avgFreq / 255, 1 + avgFreq / 255);
                torusKnot.rotation.x += 0.01;
                torusKnot.rotation.y += 0.01;
            }

            // Rotate fractal for added dynamic effect
            fractalMesh.rotation.x += 0.002;
            fractalMesh.rotation.y += 0.003;

            // Particles slight movement for atmospheric effect
            particles.rotation.y += 0.0005;
            particles.rotation.x += 0.0002;

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
