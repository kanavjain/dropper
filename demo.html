<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planisphere Music Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';
        import { AudioAnalyser } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/audio/AudioAnalyser.js';

        // Basic setup
        let scene, camera, renderer, controls;
        let particles, analyser, planets = [], path = [];
        let speed = 0.05;

        function init() {
            // Set up the scene
            scene = new THREE.Scene();
            
            // Set up the camera
            camera = new THREE.PerspectiveCamera(
                75, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(0, 2, 10);
            
            // Set up the renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Add controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.maxPolarAngle = Math.PI / 2;

            // Set up particles
            const particleCount = 5000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 200; // Spread particles around
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Set up planets (spheres) to simulate flying through galaxies
            const planetCount = 50;
            for (let i = 0; i < planetCount; i++) {
                const geometry = new THREE.SphereGeometry(Math.random() * 2 + 0.5, 32, 32);
                const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(`hsl(${Math.random() * 360}, 100%, 50%)`) });
                const planet = new THREE.Mesh(geometry, material);
                planet.position.set(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 20,
                    -i * 50 - 50
                );
                scene.add(planet);
                planets.push(planet);
            }

            // Set up path for an audiosurf-like experience
            const pathLength = 200;
            for (let i = 0; i < pathLength; i++) {
                const pathSegment = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 50, 32),
                    new THREE.MeshBasicMaterial({ color: 0x333333, opacity: 0.5, transparent: true })
                );
                pathSegment.position.set(0, -2, -i * 50);
                pathSegment.rotation.x = Math.PI / 2;
                scene.add(pathSegment);
                path.push(pathSegment);
            }

            // Set up lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);

            // Set up audio analyser using device microphone
            const listener = new THREE.AudioListener();
            camera.add(listener);
            const audio = new THREE.Audio(listener);

            navigator.mediaDevices.getUserMedia({ audio: true }).then(function (stream) {
                const audioContext = listener.context;
                const source = audioContext.createMediaStreamSource(stream);
                audio.setNodeSource(source);
                analyser = new AudioAnalyser(audio, 128);
            }).catch(function (err) {
                console.error('Unable to access the microphone', err);
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (analyser) {
                // Update particles, planets, and path based on audio
                const data = analyser.getFrequencyData();
                const bass = data.slice(0, 8).reduce((a, b) => a + b) / 8;
                const mid = data.slice(8, 16).reduce((a, b) => a + b) / 8;
                const treble = data.slice(16, data.length).reduce((a, b) => a + b) / (data.length - 16);

                // Map bass to speed and particle pulsation
                speed = 0.05 + bass / 512;
                const bassScale = bass / 256;
                particles.scale.set(bassScale + 0.8, bassScale + 0.8, bassScale + 0.8);
                particles.material.size = bassScale * 0.5 + 0.2;

                // Map mid frequencies to planet rotations
                planets.forEach((planet, index) => {
                    planet.rotation.y += 0.005 + mid / 1024;
                    planet.rotation.x += 0.002 + (index % 2 === 0 ? mid / 2048 : 0);
                });

                // Map treble frequencies to camera movement (simulate flying through space)
                camera.position.z -= speed;
                if (camera.position.z < -1500) {
                    camera.position.z = 10; // Reset position to create loop effect
                }
            }

            // Rotate particles slowly for a mesmerizing effect
            particles.rotation.y += 0.001;
            particles.rotation.x += 0.0005;

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
