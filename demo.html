<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Enhanced WebGL Synesthetic Visualizer</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000000; /* OLED black */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .control-button {
            padding: 8px 12px;
            background: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
            transition: background 0.3s, transform 0.2s;
        }
        .control-button.active {
            background: #00cc66;
            color: #ffffff;
        }
        .control-button:hover {
            background: #dddddd;
            transform: scale(1.05);
        }
        .control-slider {
            width: 150px;
            transition: all 0.3s ease;
        }
        .control-label {
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="gpuCanvas"></canvas>
    <div id="controls">
        <button id="darkModeToggle" class="control-button">Toggle Dark Mode</button>
        <button id="vibrationToggle" class="control-button">Toggle Vibrations</button>
        <button id="audioSyncToggle" class="control-button">Toggle Audio Sync</button>
        <button id="resetConfig" class="control-button">Reset Configuration</button>
        <button id="preset1" class="control-button">Preset 1</button>
        <button id="preset2" class="control-button">Preset 2</button>
        <label class="control-label" for="sensitivitySlider">Sensitivity:</label>
        <input type="range" id="sensitivitySlider" class="control-slider" min="0.1" max="3.0" step="0.1" value="1.0">
        <label class="control-label" for="intensitySlider">Intensity:</label>
        <input type="range" id="intensitySlider" class="control-slider" min="0.1" max="3.0" step="0.1" value="1.0">
    </div>
    <script>
        const canvas = document.getElementById('gpuCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            console.error('WebGL not supported');
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        let darkMode = false;
        let vibrationsEnabled = true;
        let audioSync = true;
        let sensitivity = 1.0;
        let intensity = 1.0;
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        let deviceMotion = { x: 0, y: 0, z: 0 };
        let audioContext, analyser, microphone;
        let bufferLength, dataArray;

        // Resize canvas function
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // WebGL Shader Setup
        const vertexShaderSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = a_position * 0.5 + 0.5;
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform float u_time;
            uniform vec2 u_resolution;
            uniform float u_intensity;
            varying vec2 v_uv;

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            float fbm(vec2 p) {
                float f = 0.0;
                f += 0.5000 * noise(p); p *= 2.02;
                f += 0.2500 * noise(p); p *= 2.03;
                f += 0.1250 * noise(p); p *= 2.01;
                f += 0.0625 * noise(p);
                return f;
            }

            void main() {
                vec2 uv = v_uv - 0.5;
                float dist = length(uv);
                float angle = atan(uv.y, uv.x);

                float flow = sin(u_time + dist * 10.0 + fbm(uv * 10.0)) * 0.1;
                uv += flow * 0.2;

                vec3 baseColor = vec3(
                    0.5 + 0.5 * sin(u_time + angle),
                    0.5 + 0.5 * cos(u_time * 1.5 + angle * 2.0),
                    0.5 + 0.5 * sin(u_time * 0.8 + angle * 3.0)
                );

                baseColor *= u_intensity;

                float fbmValue = fbm(uv * 6.0 + u_time * 0.8);
                baseColor.rgb += fbmValue * 0.3;

                float radialGradient = smoothstep(0.8, 0.1, dist) * (1.0 + sin(u_time * 2.5 + dist * 20.0) * 0.2);
                baseColor *= radialGradient;

                float glow = exp(-dist * 8.0);
                baseColor += vec3(glow * 0.5, glow * 0.7, glow * 1.0);

                float scanline = sin(uv.y * 800.0 + u_time * 10.0) * 0.05;
                baseColor -= scanline;

                gl_FragColor = vec4(baseColor, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                throw new Error('Shader compile error');
            }
            return shader;
        }

        function createShaderProgram(vertexSource, fragmentSource) {
            const vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link failed: ' + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                throw new Error('Program link error');
            }
            return program;
        }

        const program = createShaderProgram(vertexShaderSource, fragmentShaderSource);
        gl.useProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            -1, 1,
            1, -1,
            1, 1,
        ]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const intensityLocation = gl.getUniformLocation(program, 'u_intensity');

        // Event Listeners
        document.getElementById('darkModeToggle').addEventListener('click', () => {
            darkMode = !darkMode;
            document.getElementById('darkModeToggle').classList.toggle('active', darkMode);
        });

        document.getElementById('vibrationToggle').addEventListener('click', () => {
            vibrationsEnabled = !vibrationsEnabled;
            document.getElementById('vibrationToggle').classList.toggle('active', vibrationsEnabled);
        });

        document.getElementById('audioSyncToggle').addEventListener('click', () => {
            audioSync = !audioSync;
            document.getElementById('audioSyncToggle').classList.toggle('active', audioSync);
        });

        document.getElementById('resetConfig').addEventListener('click', () => {
            darkMode = false;
            vibrationsEnabled = true;
            audioSync = true;
            sensitivity = 1.0;
            intensity = 1.0;
            document.getElementById('sensitivitySlider').value = 1.0;
            document.getElementById('intensitySlider').value = 1.0;
            document.getElementById('darkModeToggle').classList.remove('active');
            document.getElementById('vibrationToggle').classList.add('active');
            document.getElementById('audioSyncToggle').classList.add('active');
        });

        document.getElementById('sensitivitySlider').addEventListener('input', (event) => {
            sensitivity = parseFloat(event.target.value);
        });

        document.getElementById('intensitySlider').addEventListener('input', (event) => {
            intensity = parseFloat(event.target.value);
        });

        // Access Microphone
        async function startMicrophone() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 128;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                microphone.connect(analyser);
            } catch (err) {
                console.error('Error accessing microphone:', err);
            }
        }

        startMicrophone();

        // Render loop
        function render(time) {
            time *= 0.001; // Convert to seconds

            // Update uniforms
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(intensityLocation, intensity);

            // Draw
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
