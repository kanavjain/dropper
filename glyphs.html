<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Guitar-Inspired Visualizer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>

    <script>
        // Set up the PlayCanvas application
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const app = new pc.Application(canvas, {});

        // Set canvas to full screen
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.start();

        // Set background color
        app.scene.skyboxMip = 0;
        app.scene.ambientLight = new pc.Color(0.05, 0.05, 0.1); // Darker ambient light for more contrast

        // Create camera with smooth forward motion
        const camera = new pc.Entity();
        camera.addComponent("camera", {
            clearColor: new pc.Color(0, 0, 0),
            fov: 75 // Adjusted FOV for a more compressed look
        });
        camera.setLocalPosition(0, 2, 60); // Camera stays steady for consistent perspective
        app.root.addChild(camera);

        // Create directional light for depth
        const light1 = new pc.Entity();
        light1.addComponent("light", {
            type: "directional",
            color: new pc.Color(1, 1, 0.9),
            intensity: 1.5,
            shadowDistance: 50
        });
        light1.setLocalEulerAngles(30, 30, 0); 
        app.root.addChild(light1);

        // Object types and arrays
        const sceneObjects = [];
        const objectDistance = 30; // Regularly spaced objects
        const structurePattern = ['building', 'pole', 'abstract']; // Structured patterns of objects

        // Horizon or skybox to simulate the background
        function createHorizon() {
            const horizon = new pc.Entity();
            horizon.addComponent("model", {
                type: "sphere"
            });
            horizon.setLocalScale(100, 50, 100);
            horizon.setLocalPosition(0, -50, -300);
            horizon.model.material = new pc.StandardMaterial();
            horizon.model.material.diffuse = new pc.Color(0.1, 0.1, 0.2); 
            horizon.model.material.update();
            app.root.addChild(horizon);
        }

        createHorizon();

        // Function to create structured objects with depth for parallax effect
        function createObject(x, z, type, depthFactor) {
            const object = new pc.Entity();

            if (type === 'building') {
                object.addComponent("model", { type: "box" }); // Tall buildings
            } else if (type === 'pole') {
                object.addComponent("model", { type: "cylinder" }); // Slim poles
            } else {
                object.addComponent("model", { type: "sphere" }); // Abstract spheres
            }

            // Adjust scale based on type
            const scaleFactor = (type === 'building') ? (Math.random() * 3 + 4) : (type === 'pole') ? (Math.random() * 2 + 5) : (Math.random() * 1 + 2);
            object.setLocalScale(scaleFactor * depthFactor, scaleFactor * depthFactor, scaleFactor * depthFactor);
            object.setLocalPosition(x * depthFactor, 0, z * depthFactor);

            // Set material colors for variety
            object.model.material = new pc.StandardMaterial();
            object.model.material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());
            object.model.material.update();

            object.userData = { depthFactor }; // Store the depth factor for parallax effect
            app.root.addChild(object);
            sceneObjects.push(object);
        }

        // Populate the scene with repeating structure patterns (left, right, center objects) and depth factor
        function populateScene() {
            for (let i = 0; i < 100; i++) {
                const type = structurePattern[i % structurePattern.length]; // Repeat pattern

                const depthFactor = Math.random() * 0.5 + 0.5; // Objects further away have lower depth factor

                createObject(-10, -i * objectDistance, type, depthFactor); // Left side
                createObject(10, -i * objectDistance, type, depthFactor);  // Right side
                createObject(0, -i * objectDistance, type, depthFactor);   // Center objects
            }
        }

        populateScene();

        // Move objects forward at a constant speed with parallax effect
        function updateScene(dt) {
            sceneObjects.forEach((obj) => {
                const depthFactor = obj.userData.depthFactor || 1;
                obj.translateLocal(0, 0, dt * depthFactor * 15); // Faster movement for foreground, slower for background

                obj.rotate(0, dt * 10, 0); // Subtle rotation for objects

                if (obj.getLocalPosition().z > camera.getLocalPosition().z) {
                    obj.translateLocal(0, 0, -3000); // Recycle objects when out of view
                }
            });
        }

        // Audio analysis for beat sync
        let audioContext, analyser, dataArray;

        function startMicCapture() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function (stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);

                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 128; // Increased for more frequency bins
                    dataArray = new Uint8Array(analyser.frequencyBinCount);

                    source.connect(analyser);

                    // Sync visuals with beat
                    app.on("update", updateVisualizer);
                })
                .catch(function (err) {
                    console.error('Error accessing microphone: ' + err);
                    alert('Please enable microphone access for the audio visualizer.');
                });
        }

        // Update objects' size and sync with audio frequency
        function updateVisualizer(dt) {
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);

                sceneObjects.forEach((obj, i) => {
                    const freq = dataArray[i % dataArray.length] / 255;
                    obj.setLocalScale(freq * 3 + 1, freq * 5 + 1, freq * 3 + 1); // Adjust size based on frequency
                    obj.rotate(0, freq * 2, 0); // Subtle rotation based on beat
                });
            }

            // Move the scene forward
            updateScene(dt);
        }

        // Start microphone capture on page load
        window.onload = function () {
            startMicCapture();
        };

        // Handle window resizing
        window.addEventListener("resize", function () {
            app.resizeCanvas(canvas.width, canvas.height);
        });
    </script>
</body>
</html>
