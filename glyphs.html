<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Music Visualizer</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>

    <script>
        // Set up the PlayCanvas application
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const app = new pc.Application(canvas, {});

        // Set canvas to full screen
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.start();

        // Set background color
        app.scene.skyboxMip = 0;
        app.scene.ambientLight = new pc.Color(0.1, 0.1, 0.1);

        // Create camera that moves forward through the scene
        const camera = new pc.Entity();
        camera.addComponent("camera", {
            clearColor: new pc.Color(0, 0, 0),
            fov: 75 // Widen the field of view for more visibility
        });
        camera.setLocalPosition(0, 2, 30); // Move camera back to see more objects
        app.root.addChild(camera);

        // Create directional lights
        const light1 = new pc.Entity();
        light1.addComponent("light", {
            type: "directional",
            color: new pc.Color(1, 1, 1),
            intensity: 2 // Increase intensity for better illumination
        });
        light1.setLocalEulerAngles(45, 30, 0);
        app.root.addChild(light1);

        const light2 = new pc.Entity();
        light2.addComponent("light", {
            type: "directional",
            color: new pc.Color(0.5, 0.5, 1), // Slight blue tint for visual variety
            intensity: 1.5
        });
        light2.setLocalEulerAngles(-45, -30, 0);
        app.root.addChild(light2);

        // Scene Arrays
        const sceneObjects = [];
        const objectDistance = 10;

        // Create horizon or skybox simulation
        function createHorizon() {
            const horizon = new pc.Entity();
            horizon.addComponent("model", {
                type: "sphere"
            });
            horizon.setLocalScale(100, 50, 100);
            horizon.setLocalPosition(0, -50, -300);
            horizon.model.material = new pc.StandardMaterial();
            horizon.model.material.diffuse = new pc.Color(0.2, 0.2, 0.4);
            horizon.model.material.update();
            app.root.addChild(horizon);
        }

        createHorizon();

        // Object creator for buildings, trees, and other elements
        function createObject(x, z, type) {
            const object = new pc.Entity();
            object.addComponent("model", {
                type: type === 'box' ? "box" : "cylinder"
            });

            if (type === 'box') {
                object.setLocalScale(3, Math.random() * 7 + 3, 3); // Larger scaling for buildings
            } else if (type === 'tree') {
                object.setLocalScale(2, Math.random() * 5 + 4, 2); // Larger trees
            } else {
                object.setLocalScale(1, Math.random() * 6 + 2, 1); // Abstract shapes
            }

            object.setLocalPosition(x, 0, z);
            app.root.addChild(object);
            sceneObjects.push(object);
        }

        // Populate scene with trees, buildings, and abstract shapes
        function populateScene() {
            for (let i = 0; i < 200; i++) { // Increase number of objects
                const type = Math.random() > 0.5 ? 'box' : 'tree';
                createObject(-6, -i * objectDistance, type); // Left side
                createObject(6, -i * objectDistance, type);  // Right side
                if (Math.random() > 0.6) {
                    createObject(0, -i * objectDistance, 'abstract'); // Abstract objects in the middle
                }
            }
        }

        populateScene();

        // Object recycling and camera movement
        function updateScene(dt) {
            camera.translateLocal(0, 0, -dt * 10); // Forward movement

            sceneObjects.forEach((obj) => {
                if (obj.getLocalPosition().z > camera.getLocalPosition().z) {
                    obj.translateLocal(0, 0, -1000); // Move back when out of view
                }
            });
        }

        // Debugging markers to visualize object positions
        function createMarker(x, z) {
            const marker = new pc.Entity();
            marker.addComponent("model", { type: "sphere" });
            marker.setLocalScale(0.5, 0.5, 0.5); // Small marker size
            marker.setLocalPosition(x, 0, z);
            app.root.addChild(marker);
        }

        // Use markers to debug object positions
        createMarker(0, 0); // At the camera's initial position
        createMarker(-6, -10); // On the left side
        createMarker(6, -10); // On the right side

        // Audio analyzer setup
        let audioContext, analyser, dataArray;

        function startMicCapture() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function (stream) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);

                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 64;
                    dataArray = new Uint8Array(analyser.frequencyBinCount);

                    source.connect(analyser);

                    // Sync visuals with beat
                    app.on("update", updateVisualizer);
                })
                .catch(function (err) {
                    console.error('Error accessing microphone: ' + err);
                });
        }

        function updateVisualizer(dt) {
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);

                // Sync object scale or movement with frequency data
                sceneObjects.forEach((obj, i) => {
                    const freq = dataArray[i % dataArray.length] / 255;
                    obj.setLocalScale(2, freq * 8 + 2, 2); // Vary height with audio
                    obj.translateLocal(0, freq * 0.5, 0); // Subtle vertical movement

                    // Sync color to high-frequency sounds
                    if (freq > 0.5) {
                        obj.model.material.emissive = new pc.Color(freq, freq, freq * 0.5);
                        obj.model.material.update();
                    }
                });

                // Add sway to the camera based on frequencies
                const cameraSway = dataArray[0] / 255;
                camera.translateLocal(cameraSway * 0.02, 0, 0); // Slight lateral movement
            }

            // Update scene for movement and recycling
            updateScene(dt);
        }

        // Start microphone capture when the page loads
        window.onload = function () {
            startMicCapture();
        };

        // Handle window resizing
        window.addEventListener("resize", function () {
            app.resizeCanvas(canvas.width, canvas.height);
        });
    </script>
</body>
</html>
