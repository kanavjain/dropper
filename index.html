<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Metallic Ball Visualizer</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000000; /* OLED black */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            console.error('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                throw new Error('Shader compile error');
            }
            return shader;
        }

        // Vertex shader source
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_normal;
            uniform mat4 u_modelViewMatrix;
            uniform mat4 u_projectionMatrix;
            varying vec3 v_normal;
            varying vec3 v_position;
            void main() {
                v_normal = a_normal;
                v_position = (u_modelViewMatrix * vec4(a_position, 1.0)).xyz;
                gl_Position = u_projectionMatrix * vec4(a_position, 1.0);
            }
        `;

        // Fragment shader source for metallic ball effect
        const fragmentShaderSource = `
            precision mediump float;
            uniform vec3 u_lightDirection;
            uniform vec3 u_cameraPosition;
            uniform float u_time;
            varying vec3 v_normal;
            varying vec3 v_position;

            void main() {
                vec3 normal = normalize(v_normal);
                vec3 lightDir = normalize(u_lightDirection);
                vec3 viewDir = normalize(u_cameraPosition - v_position);

                // Metallic shading
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 reflectDir = reflect(-lightDir, normal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 color = vec3(0.4, 0.4, 0.4) * diff + vec3(1.0, 1.0, 1.0) * spec * 0.5;

                // Adding time-based color variation for subtle beauty
                color += 0.1 * sin(u_time * 0.5) * vec3(0.8, 0.6, 0.5);
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Create and link program
        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program link failed: ' + gl.getProgramInfoLog(program));
            throw new Error('Program link error');
        }
        gl.useProgram(program);

        // Set up geometry for a sphere
        function createSphere(radius, latitudeBands, longitudeBands) {
            const positions = [];
            const normals = [];
            const indices = [];

            for (let lat = 0; lat <= latitudeBands; ++lat) {
                const theta = lat * Math.PI / latitudeBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let lon = 0; lon <= longitudeBands; ++lon) {
                    const phi = lon * 2 * Math.PI / longitudeBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;

                    positions.push(radius * x);
                    positions.push(radius * y);
                    positions.push(radius * z);

                    normals.push(x);
                    normals.push(y);
                    normals.push(z);
                }
            }

            for (let lat = 0; lat < latitudeBands; ++lat) {
                for (let lon = 0; lon < longitudeBands; ++lon) {
                    const first = (lat * (longitudeBands + 1)) + lon;
                    const second = first + longitudeBands + 1;

                    indices.push(first);
                    indices.push(second);
                    indices.push(first + 1);

                    indices.push(second);
                    indices.push(second + 1);
                    indices.push(first + 1);
                }
            }

            return { positions, normals, indices };
        }

        const sphereData = createSphere(1, 30, 30);
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereData.positions), gl.STATIC_DRAW);

        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sphereData.normals), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sphereData.indices), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(positionLocation);

        const normalLocation = gl.getAttribLocation(program, 'a_normal');
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(normalLocation);

        // Set up uniforms
        const modelViewMatrixLocation = gl.getUniformLocation(program, 'u_modelViewMatrix');
        const projectionMatrixLocation = gl.getUniformLocation(program, 'u_projectionMatrix');
        const lightDirectionLocation = gl.getUniformLocation(program, 'u_lightDirection');
        const cameraPositionLocation = gl.getUniformLocation(program, 'u_cameraPosition');
        const timeLocation = gl.getUniformLocation(program, 'u_time');

        const lightDirection = [1.0, 1.0, 1.0];
        const cameraPosition = [0.0, 0.0, 5.0];

        // Set up projection matrix
        const fieldOfView = Math.PI / 4;
        const aspect = canvas.width / canvas.height;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        // Set up model view matrix
        const modelViewMatrix = mat4.create();
        mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -5.0]);

        // Animation variables
        let ballPosition = [0, 0];
        let ballVelocity = [0.02, 0.015];

        // Render loop
        function render(time) {
            time *= 0.001; // Convert time to seconds

            // Update ball position and handle collisions with screen edges
            ballPosition[0] += ballVelocity[0];
            ballPosition[1] += ballVelocity[1];

            if (ballPosition[0] > 1.5 || ballPosition[0] < -1.5) {
                ballVelocity[0] = -ballVelocity[0];
                navigator.vibrate([50, 100, 50]); // Vibrate with a pattern on collision with edge
            }
            if (ballPosition[1] > 1.5 || ballPosition[1] < -1.5) {
                ballVelocity[1] = -ballVelocity[1];
                navigator.vibrate([50, 100, 50]); // Vibrate with a pattern on collision with edge
            }

            // Update model view matrix for ball position
            mat4.identity(modelViewMatrix);
            mat4.translate(modelViewMatrix, modelViewMatrix, [ballPosition[0], ballPosition[1], -5.0]);

            // Clear canvas
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Set uniforms
            gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);
            gl.uniformMatrix4fv(projectionMatrixLocation, false, projectionMatrix);
            gl.uniform3fv(lightDirectionLocation, lightDirection);
            gl.uniform3fv(cameraPositionLocation, cameraPosition);
            gl.uniform1f(timeLocation, time);

            // Draw sphere
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, sphereData.indices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</body>
</html>
