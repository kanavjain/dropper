<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unexpected Music Visualizer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    button {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      font-size: 16px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <button id="start-button">Start Microphone</button>

  <script type="module">
    import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/three.module.min.js';

    let audioContext;
    let analyser;
    let dataArray;
    let currentLegibilityFactor = 0;
    let micStream;

    const startButton = document.getElementById('start-button');
    startButton.addEventListener('click', startMicAudio);

    function startMicAudio() {
      // Request access to the microphone
      navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(stream => {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = 2048;
          const bufferLength = analyser.frequencyBinCount;
          dataArray = new Uint8Array(bufferLength);

          // Create media stream source from microphone
          micStream = audioContext.createMediaStreamSource(stream);
          micStream.connect(analyser);
          
          // Hide the start button after the microphone is started
          startButton.style.display = 'none';

          // Start the render loop
          render();
        })
        .catch(err => {
          console.error('Error accessing the microphone', err);
        });
    }

    // Beat detection function using microphone input
    function getBeat() {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      return sum / dataArray.length;  // Return average frequency
    }

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const fontLoader = new THREE.FontLoader();
    let textMeshes = [];
    let font;

    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
      font = loadedFont;
      createTextMeshes();
    });

    // Full text to render
    const fullText = 'Unexpected effects in a music visualizer. Shattering, Swarming, Defying gravity.';
    const words = fullText.split(' ');
    const revealedWords = Array(words.length).fill(false);

    // Create text meshes for each word
    function createTextMeshes() {
      words.forEach((word, index) => {
        const geometry = new THREE.TextGeometry(word, {
          font: font,
          size: 0.5,
          height: 0.05,
        });

        const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
        const mesh = new THREE.Mesh(geometry, material);

        // Random initial positions for the words
        mesh.position.set(Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 5 - 10);
        textMeshes.push(mesh);
        scene.add(mesh);
      });

      camera.position.z = 15;  // Adjust camera to see all words initially
    }

    // Beat-driven word behavior
    function updateWordsBasedOnBeat(beatStrength) {
      // Text shattering effect on beat peaks
      textMeshes.forEach((mesh, index) => {
        const distanceFromCenter = Math.abs(mesh.position.x) + Math.abs(mesh.position.y);
        const threshold = beatStrength / 10;

        if (distanceFromCenter < threshold) {
          // Push words outward, "shattering" them away from the center
          mesh.position.x += (Math.random() - 0.5) * beatStrength * 0.02;
          mesh.position.y += (Math.random() - 0.5) * beatStrength * 0.02;
          mesh.rotation.z += (Math.random() - 0.5) * beatStrength * 0.001;
        }
      });
    }

    // Apply gravity-defying behavior to words
    function applyGravityDefyingEffect(beatStrength) {
      textMeshes.forEach((mesh) => {
        // Add a sine-based oscillation to simulate gravity-defying text movement
        const oscillationFactor = Math.sin(Date.now() * 0.001) * (beatStrength * 0.01);
        mesh.position.y += oscillationFactor;
      });
    }

    // Word swarming effect - words "attract" toward random points
    function applySwarmEffect(beatStrength) {
      const targetPoint = new THREE.Vector3(Math.random() * 4 - 2, Math.random() * 4 - 2, Math.random() * -5);
      textMeshes.forEach((mesh) => {
        // Move each word toward the target point
        mesh.position.lerp(targetPoint, 0.01 + (beatStrength * 0.001));  // Speed increases with beat
      });
    }

    // Render loop
    function render() {
      requestAnimationFrame(render);
      if (analyser) {
        const beatStrength = getBeat();

        // Apply the effects
        updateWordsBasedOnBeat(beatStrength);
        applyGravityDefyingEffect(beatStrength);
        applySwarmEffect(beatStrength);
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
