<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Visualizer with WebGPU Fallback</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
    <script type="module">
        import * as pc from 'https://code.playcanvas.com/playcanvas-stable.min.js';

        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);

        // Check if WebGPU is supported
        const isWebGPUSupported = !!navigator.gpu;
        let app;

        if (isWebGPUSupported) {
            console.log("WebGPU is supported, using WebGPU.");
            app = new pc.Application(canvas, {
                graphicsDeviceOptions: {
                    preferredGraphicsDevice: "webgpu"  // Use WebGPU for enhanced performance
                }
            });
        } else {
            console.log("WebGPU is not supported, falling back to WebGL.");
            app = new pc.Application(canvas, {
                graphicsDeviceOptions: {
                    preferredGraphicsDevice: "webgl"  // Fallback to WebGL
                }
            });
        }

        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.start();

        // Set background color
        app.scene.ambientLight = new pc.Color(0.05, 0.05, 0.1);

        // Create camera with bloom post-processing
        const camera = new pc.Entity();
        camera.addComponent("camera", {
            clearColor: new pc.Color(0, 0, 0),
            fov: 60
        });
        camera.setLocalPosition(0, 0.5, 20);
        app.root.addChild(camera);

        // Add bloom post-processing effect from PlayCanvas
        const bloom = new pc.BloomEffect(app.graphicsDevice, {
            bloomThreshold: 0.7,   // Only apply bloom to bright areas
            bloomIntensity: 1.2,   // Increase the strength of the bloom effect
            blurAmount: 4.0        // Amount of blurring in the bloom effect
        });
        camera.camera.postEffects.addEffect(bloom);

        // Create a directional light
        const light = new pc.Entity();
        light.addComponent("light", {
            type: "directional",
            color: new pc.Color(1, 1, 0.9),
            intensity: 1.5
        });
        light.setLocalEulerAngles(30, 30, 0);
        app.root.addChild(light);

        // Scene objects
        const sceneObjects = [];
        const objectDistance = 15;

        // Create scene objects with random colors
        function createObject(x, z, type) {
            const object = new pc.Entity();
            object.addComponent("model", { type: "box" });

            const material = new pc.StandardMaterial();
            material.diffuse = new pc.Color(Math.random(), Math.random(), Math.random());
            material.update();

            object.model.material = material;
            object.setLocalScale(5, 5, 5);
            object.setLocalPosition(x, 0, z);

            app.root.addChild(object);
            sceneObjects.push(object);
        }

        function populateScene() {
            for (let i = 0; i < 100; i++) {
                createObject(Math.random() * 30 - 15, -i * objectDistance, 'box');
            }
        }

        populateScene();

        // Web Audio API for real-time audio analysis
        let audioContext, analyser;
        function startAudioProcessing() {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);

                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 128;
                    source.connect(analyser);

                    app.on("update", updateVisualizer);
                })
                .catch(err => {
                    console.error('Error accessing microphone: ' + err);
                });
        }

        function updateVisualizer(dt) {
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(frequencyData);

            sceneObjects.forEach((obj, i) => {
                const scaleFactor = frequencyData[i % frequencyData.length] / 255;
                obj.setLocalScale(scaleFactor * 5 + 1, scaleFactor * 5 + 1, scaleFactor * 5 + 1);
            });
        }

        window.onload = function () {
            startAudioProcessing();
        };

        // Handle window resizing
        window.addEventListener("resize", function () {
            app.resizeCanvas(canvas.width, canvas.height);
        });
    </script>
</head>
<body>
</body>
</html>
