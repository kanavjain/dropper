<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU/WebGL Visualizer with Sound and Motion</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/three.module.js';
        import { WebGPURenderer } from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.169.0/three.webgpu.min.js';

        let renderer, isWebGPUSupported = false;

        // Try to initialize WebGPU
        if (navigator.gpu) {
            try {
                renderer = new WebGPURenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                isWebGPUSupported = true;
                console.log("WebGPU is supported and running.");
            } catch (error) {
                console.error("Failed to initialize WebGPU, falling back to WebGL: ", error);
                isWebGPUSupported = false;
            }
        }

        // Fallback to WebGL if WebGPU is not supported
        if (!isWebGPUSupported) {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            console.log("WebGL is running.");
        }

        document.body.appendChild(renderer.domElement);

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        // Torus knot geometry
        const geometry = new THREE.TorusKnotGeometry(10, 3, 100, 16);
        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, metalness: 0.5, roughness: 0.2 });
        const torusKnot = new THREE.Mesh(geometry, material);
        scene.add(torusKnot);

        // Basic lighting
        const ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xff0000, 2, 100);
        pointLight.position.set(10, 20, 20);
        scene.add(pointLight);

        // Audio input setup
        let analyser;
        let dataArray;
        navigator.mediaDevices.getUserMedia({ audio: true }).then(function(stream) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const audioSource = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            audioSource.connect(analyser);
        }).catch(function(err) {
            console.error('The following error occurred: ' + err);
        });

        // Device orientation handler
        let rotationX = 0, rotationY = 0;
        window.addEventListener('deviceorientation', (event) => {
            const alpha = event.alpha ? THREE.Math.degToRad(event.alpha) : 0; // Z-axis rotation
            const beta = event.beta ? THREE.Math.degToRad(event.beta) : 0;   // X-axis rotation
            const gamma = event.gamma ? THREE.Math.degToRad(event.gamma) : 0; // Y-axis rotation

            rotationX = beta;
            rotationY = gamma;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (analyser && dataArray) {
                analyser.getByteFrequencyData(dataArray);
                const avgFrequency = dataArray.reduce((acc, val) => acc + val, 0) / dataArray.length;

                // Change the color based on frequency data
                const frequencyColor = new THREE.Color(avgFrequency / 255, 1 - avgFrequency / 255, 0.5);
                torusKnot.material.color.set(frequencyColor);

                // Adjust torus rotation based on sound frequency
                torusKnot.rotation.x += avgFrequency / 5000;
                torusKnot.rotation.y += avgFrequency / 5000;

                // Light intensity reacts to sound
                pointLight.intensity = avgFrequency / 100;
            }

            // Rotate based on device orientation
            torusKnot.rotation.x += rotationX * 0.01;
            torusKnot.rotation.y += rotationY * 0.01;

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
