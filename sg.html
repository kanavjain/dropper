<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Star Guitar Inspired Visualizer</title>
    <style>
        html, body {
            margin: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
        }
        canvas {
            display: block;
        }
        /* VHS effect styling */
        .vhs-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            mix-blend-mode: lighten;
            opacity: 0.2;
            background: repeating-linear-gradient(
                0deg,
                rgba(255, 255, 255, 0.02),
                rgba(255, 255, 255, 0.02) 2px,
                transparent 2px,
                transparent 4px
            );
            animation: vhsNoise 0.1s infinite;
        }

        @keyframes vhsNoise {
            0% { transform: translateY(0); }
            25% { transform: translateY(-2px); }
            50% { transform: translateY(1px); }
            75% { transform: translateY(-1px); }
            100% { transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="vhs-effect"></div>
    <!-- Include Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        let scene, camera, renderer, clock, directionalLight;
        let analyser, frequencyData;
        let lastBeatTime = 0;
        const minBeatInterval = 300; // Minimum interval between beats in milliseconds
        const scenery = [];
        const beatThreshold = 170;
        const modularElements = [];
        const modularElementSpacing = 20;
        const cameraSpeed = 15;
        const cameraShakeDecay = 0.95;
        let cameraShakeOffset = { x: 0, y: 0 };

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 200);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 5);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.style.filter = 'blur(1px) contrast(1.2)'; // Add slight blur and contrast for VHS feel
            document.body.appendChild(renderer.domElement);

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xddddff, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffcc88, 1.2);
            directionalLight.position.set(0, 50, -50);
            scene.add(directionalLight);

            // Initialize scene elements
            createInitialScenery();
            createModularElements();

            // Initialize clock
            clock = new THREE.Clock();

            // Setup audio
            setupAudio();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createInitialScenery() {
            // Create repeating scenery elements like trees, buildings, and train tracks
            for (let i = 0; i < 100; i++) {
                createSynchronizedSceneryElement(-i * 20);
            }
        }

        function createSynchronizedSceneryElement(zPosition) {
            const geometry = new THREE.BoxGeometry(1, Math.random() * 5 + 2, 1);
            const material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
            const element = new THREE.Mesh(geometry, material);
            element.position.set(
                Math.random() * 40 - 20, // Random X position for variety
                geometry.parameters.height / 2,
                zPosition // Place at specified z position
            );
            element.castShadow = true;
            scene.add(element);
            scenery.push(element);
        }

        function createModularElements() {
            // Create modular repeating elements like train tracks, poles, and tunnels
            const trackGeometry = new THREE.BoxGeometry(5, 0.1, modularElementSpacing);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            for (let i = 0; i < 200; i++) {
                const track = new THREE.Mesh(trackGeometry, trackMaterial);
                track.position.set(0, 0, -i * modularElementSpacing);
                track.receiveShadow = true;
                scene.add(track);
                modularElements.push(track);
            }

            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 10, 16);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
            for (let i = 0; i < 100; i++) {
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(-10, 5, -i * modularElementSpacing * 2);
                pole.castShadow = true;
                scene.add(pole);
                modularElements.push(pole);
            }
        }

        function setupAudio() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('getUserMedia not supported on your browser!');
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(function (stream) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    source.connect(analyser);
                    frequencyData = new Uint8Array(analyser.frequencyBinCount);
                })
                .catch(function (err) {
                    alert('Could not access microphone: ' + err.message + '. Please try again.');
                    console.error('The following getUserMedia error occurred: ', err);
                });
        }

        // Improved beat detection using low frequency energy peaks
        function handleBeatDetection() {
            const bassLevel = getFrequencyRangeValue(0, 10);
            if (bassLevel > beatThreshold && Date.now() - lastBeatTime > minBeatInterval) {
                lastBeatTime = Date.now();
                createSynchronizedSceneryElement(camera.position.z - 100);
            }
        }

        // Smooth adjustment of directional light intensity
        function updateSceneryWithSound() {
            if (analyser) {
                analyser.getByteFrequencyData(frequencyData);

                // Beat detection
                handleBeatDetection();

                // Adjust modular elements based on audio
                const bass = getFrequencyRangeValue(0, 10);
                const mid = getFrequencyRangeValue(11, 40);
                const treble = getFrequencyRangeValue(41, 60);

                // Camera shake
                const cameraShakeIntensity = bass / 150;
                cameraShakeOffset.x = (Math.random() - 0.5) * cameraShakeIntensity;
                cameraShakeOffset.y = (Math.random() - 0.5) * cameraShakeIntensity;

                // Update colors based on mid frequencies
                const colorValue = Math.min(1, mid / 255);
                modularElements.forEach(element => {
                    element.material.color.setHSL(colorValue, 0.7, 0.5);
                });

                // Smoothly adjust directional light intensity
                const targetIntensity = 0.8 + (treble / 255) * 1.2;
                directionalLight.intensity += (targetIntensity - directionalLight.intensity) * 0.1; // Use interpolation for smooth transitions
            }
        }

        function getFrequencyRangeValue(start, end) {
            const slice = frequencyData.slice(start, end);
            const sum = slice.reduce((a, b) => a + b, 0);
            return sum / slice.length;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Move the camera forward
            camera.position.z -= delta * cameraSpeed;

            // Apply camera shake
            camera.position.x += cameraShakeOffset.x;
            camera.position.y += cameraShakeOffset.y;
            cameraShakeOffset.x *= cameraShakeDecay;
            cameraShakeOffset.y *= cameraShakeDecay;

            // Update scenery with sound (every few frames for better performance)
            if (Math.floor(clock.elapsedTime * 60) % 4 === 0) {
                updateSceneryWithSound();
            }

            // Move scenery elements
            scenery.forEach(obj => {
                obj.position.z += delta * cameraSpeed;
                if (obj.position.z > camera.position.z + 50) {
                    obj.position.z -= 2000; // Reposition for continuous scenery
                }
            });

            // Move modular elements
            modularElements.forEach(obj => {
                obj.position.z += delta * cameraSpeed;
                if (obj.position.z > camera.position.z + 50) {
                    obj.position.z -= 2000; // Reposition for continuous pattern
                }
            });

            renderer.render(scene, camera);
        }

        // Initialize the visualizer
        init();
    </script>
</body>
</html>
