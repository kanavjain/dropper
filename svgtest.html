<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced SVG + PlayCanvas Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            filter: url('#displacementFilter');
        }
        @keyframes colorShift {
            0% { stop-color: rgb(255, 0, 0); }
            25% { stop-color: rgb(0, 255, 0); }
            50% { stop-color: rgb(0, 0, 255); }
            75% { stop-color: rgb(255, 255, 0); }
            100% { stop-color: rgb(255, 0, 0); }
        }
    </style>
</head>
<body>
    <!-- The SVG element for the CSS displacement map -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="0" height="0">
        <defs>
            <filter id="displacementFilter">
                <feTurbulence type="fractalNoise" baseFrequency="0.05" numOctaves="4" result="turbulence" />
                <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="70" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
        </defs>
    </svg>

    <!-- Overlay for SVG filter application -->
    <div id="overlay">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50%" cy="50%" r="150" fill="url(#grad1)" />
            <defs>
                <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                    <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:1; animation: colorShift 5s infinite alternate;" />
                    <stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />
                </radialGradient>
            </defs>
        </svg>
    </div>

    <!-- Include PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    
    <script>
        // Set up the PlayCanvas application
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const app = new pc.Application(canvas, {
            graphicsDeviceOptions: {
                alpha: true
            }
        });
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.scene.ambientLight = new pc.Color(0.3, 0.3, 0.3);
        app.start();

        // Create camera entity
        const camera = new pc.Entity();
        camera.addComponent('camera', {
            clearColor: new pc.Color(0, 0, 0, 1)
        });
        camera.setPosition(0, 0, 15);
        app.root.addChild(camera);

        // Create light entities
        const light1 = new pc.Entity();
        light1.addComponent('light', {
            type: 'point',
            color: new pc.Color(1, 0.25, 0),
            range: 50,
            intensity: 2
        });
        light1.setPosition(10, 10, 10);
        app.root.addChild(light1);

        const light2 = new pc.Entity();
        light2.addComponent('light', {
            type: 'point',
            color: new pc.Color(0, 0.25, 1),
            range: 50,
            intensity: 2
        });
        light2.setPosition(-10, -10, 10);
        app.root.addChild(light2);

        // Create sphere entity
        const sphere = new pc.Entity();
        sphere.addComponent('model', {
            type: 'sphere'
        });
        sphere.addComponent('render', {
            material: new pc.StandardMaterial()
        });
        app.root.addChild(sphere);

        // Update sphere material
        const material = sphere.render.material;
        material.shininess = 60;
        material.metalness = 0.6;
        material.update();

        // Create particle system
        const particleSystem = new pc.Entity();
        particleSystem.addComponent('particlesystem', {
            numParticles: 500,
            lifetime: 2,
            rate: 0.01,
            scaleGraph: new pc.Curve([0, 0.2, 1]),
            colorGraph: new pc.CurveSet([new pc.Curve([1, 1, 0]), new pc.Curve([1, 1, 0]), new pc.Curve([1, 1, 0])]),
            velocityGraph: new pc.Curve([0, 0.5, 1])
        });
        app.root.addChild(particleSystem);

        // Handle window resize
        window.addEventListener('resize', () => {
            app.resizeCanvas(canvas.width, canvas.height);
        });

        // Set up audio context and analyzer
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioCtx.createAnalyser();
        const audio = new Audio('path-to-your-audio-file.mp3');
        audio.crossOrigin = "anonymous";
        audio.loop = true;

        const source = audioCtx.createMediaElementSource(audio);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        analyser.fftSize = 256;

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        audio.play();

        // Interactive mouse movement
        app.mouse.on(pc.EVENT_MOUSEMOVE, (event) => {
            const mouseX = (event.x / window.innerWidth) * 2 - 1;
            const mouseY = -(event.y / window.innerHeight) * 2 + 1;
            sphere.setEulerAngles(mouseY * 50, mouseX * 50, 0);
        });

        // Main animation loop
        app.on('update', (dt) => {
            analyser.getByteFrequencyData(dataArray);

            // Modify sphere material based on audio frequency
            const displacementScale = dataArray[0] / 128;
            material.diffuse.setHSL(displacementScale / 2, 1, 0.5);
            material.update();

            // Rotate sphere for a more dynamic visual
            sphere.rotate(0.5, 0.5, 0);

            // Update particle rotation
            particleSystem.rotate(0, 0.1, 0);
        });
    </script>
</body>
</html>
