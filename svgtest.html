<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retrofuturistic SVG + PlayCanvas Visualizer with Microphone Input</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d0d, #282828);
            font-family: 'Orbitron', sans-serif;
            color: #00ffcc;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            filter: url('#displacementFilter');
            mix-blend-mode: screen;
        }
        @keyframes colorShift {
            0% { stop-color: rgb(0, 255, 153); }
            25% { stop-color: rgb(51, 51, 255); }
            50% { stop-color: rgb(255, 20, 147); }
            75% { stop-color: rgb(255, 140, 0); }
            100% { stop-color: rgb(0, 255, 153); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- The SVG element for the CSS displacement map -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="0" height="0">
        <defs>
            <filter id="displacementFilter">
                <feTurbulence type="fractalNoise" baseFrequency="0.2" numOctaves="6" result="turbulence" />
                <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="150" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
        </defs>
    </svg>

    <!-- Overlay for SVG filter application -->
    <div id="overlay">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50%" cy="50%" r="200" fill="url(#grad1)" style="animation: pulse 6s infinite alternate ease-in-out;" />
            <defs>
                <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                    <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:1; animation: colorShift 8s infinite alternate;" />
                    <stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />
                </radialGradient>
            </defs>
        </svg>
    </div>

    <!-- Include PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    
    <script>
        // Set up the PlayCanvas application
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const app = new pc.Application(canvas, {
            graphicsDeviceOptions: {
                alpha: true
            }
        });
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.scene.ambientLight = new pc.Color(0.4, 0.4, 0.4);
        app.start();

        // Create camera entity
        const camera = new pc.Entity();
        camera.addComponent('camera', {
            clearColor: new pc.Color(0, 0, 0, 1)
        });
        camera.setPosition(0, 0, 25);
        camera.lookAt(0, 0, 0);
        app.root.addChild(camera);

        // Create light entities
        const light1 = new pc.Entity();
        light1.addComponent('light', {
            type: 'point',
            color: new pc.Color(0, 1, 0.6),
            range: 100,
            intensity: 3
        });
        light1.setPosition(20, 15, 20);
        app.root.addChild(light1);

        const light2 = new pc.Entity();
        light2.addComponent('light', {
            type: 'point',
            color: new pc.Color(0.5, 0.5, 1),
            range: 100,
            intensity: 3
        });
        light2.setPosition(-20, -15, 20);
        app.root.addChild(light2);

        // Create torus entity for a retrofuturistic vibe
        const torus = new pc.Entity();
        torus.addComponent('model', {
            type: 'torus'
        });
        torus.addComponent('render', {
            material: new pc.StandardMaterial()
        });
        torus.setLocalScale(3, 3, 3);
        app.root.addChild(torus);

        // Update torus material
        const material = torus.render.material;
        material.diffuse.set(0.1, 0.8, 0.5);
        material.shininess = 100;
        material.metalness = 0.9;
        material.update();

        // Create particle system
        const particleSystem = new pc.Entity();
        particleSystem.addComponent('particlesystem', {
            numParticles: 1500,
            lifetime: 4,
            rate: 0.02,
            scaleGraph: new pc.Curve([0, 0.5, 1]),
            colorGraph: new pc.CurveSet([new pc.Curve([1, 0.8, 0]), new pc.Curve([0, 1, 1]), new pc.Curve([0, 0.8, 1])]),
            velocityGraph: new pc.Curve([0, 1, 2])
        });
        particleSystem.setLocalPosition(0, 0, -5);
        app.root.addChild(particleSystem);

        // Handle window resize
        window.addEventListener('resize', () => {
            app.resizeCanvas(canvas.width, canvas.height);
        });

        // Set up audio context and analyzer with microphone input
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioCtx.createAnalyser();
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            // Main animation loop
            app.on('update', (dt) => {
                analyser.getByteFrequencyData(dataArray);

                // Modify torus material based on audio frequency
                const displacementScale = dataArray[0] / 128;
                material.emissive.setHSL(displacementScale / 2, 1, 0.5);
                material.update();

                // Rotate torus for a more dynamic visual
                torus.rotate(1.5 * dt, 1.8 * dt, 0.5 * dt);

                // Update particle rotation and expand particles for a more dynamic effect
                particleSystem.rotate(0, 0.5 * dt, 0);
                particleSystem.particlesystem.velocityGraph = new pc.Curve([0, 1 + displacementScale, 3]);

                // Move the camera slightly based on audio input for more dynamic 3D effect
                const cameraShake = displacementScale * 0.5;
                camera.setPosition(cameraShake * Math.sin(dt * 5), cameraShake * Math.cos(dt * 5), 25);
                camera.lookAt(0, 0, 0);
            });
        }).catch((err) => {
            console.error('Microphone access denied or not available', err);
        });
    </script>
</body>
</html>
