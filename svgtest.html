<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Sound SVG + PlayCanvas Visualizer with FFT and Microphone Input</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #001f3f, #001021);
            font-family: 'Orbitron', sans-serif;
            color: #00ffcc;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            filter: url('#displacementFilter');
            mix-blend-mode: screen;
        }
        @keyframes colorShift {
            0% { stop-color: rgb(0, 255, 153); }
            25% { stop-color: rgb(51, 51, 255); }
            50% { stop-color: rgb(255, 20, 147); }
            75% { stop-color: rgb(255, 140, 0); }
            100% { stop-color: rgb(0, 255, 153); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- The SVG element for the CSS displacement map -->
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="0" height="0">
        <defs>
            <filter id="displacementFilter">
                <feTurbulence type="fractalNoise" baseFrequency="0.05" numOctaves="3" result="turbulence" />
                <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="100" xChannelSelector="R" yChannelSelector="G"/>
            </filter>
        </defs>
    </svg>

    <!-- Overlay for SVG filter application -->
    <div id="overlay">
        <svg width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <circle cx="50%" cy="50%" r="200" fill="url(#grad1)" style="animation: pulse 8s infinite alternate ease-in-out;" />
            <defs>
                <radialGradient id="grad1" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                    <stop offset="0%" style="stop-color:rgb(255,255,255);stop-opacity:1; animation: colorShift 10s infinite alternate;" />
                    <stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />
                </radialGradient>
            </defs>
        </svg>
    </div>

    <!-- Include PlayCanvas Engine -->
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    
    <script>
        // Set up the PlayCanvas application
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const app = new pc.Application(canvas, {
            graphicsDeviceOptions: {
                alpha: true
            }
        });
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        app.scene.ambientLight = new pc.Color(0.3, 0.3, 0.5);
        app.start();

        // Create camera entity
        const camera = new pc.Entity();
        camera.addComponent('camera', {
            clearColor: new pc.Color(0, 0, 0, 1)
        });
        camera.setPosition(0, 0, 30);
        app.root.addChild(camera);

        // Create light entities
        const light1 = new pc.Entity();
        light1.addComponent('light', {
            type: 'point',
            color: new pc.Color(0, 0.6, 1),
            range: 150,
            intensity: 2
        });
        light1.setPosition(10, 20, 10);
        app.root.addChild(light1);

        const light2 = new pc.Entity();
        light2.addComponent('light', {
            type: 'point',
            color: new pc.Color(0.8, 0.5, 1),
            range: 150,
            intensity: 2
        });
        light2.setPosition(-15, -10, 20);
        app.root.addChild(light2);

        // Create a smooth, flowing sphere for an ambient effect
        const sphere = new pc.Entity();
        sphere.addComponent('model', {
            type: 'sphere'
        });
        sphere.addComponent('render', {
            material: new pc.StandardMaterial()
        });
        app.root.addChild(sphere);

        // Update sphere material
        const material = sphere.render.material;
        material.diffuse.set(0.1, 0.4, 0.7);
        material.shininess = 50;
        material.metalness = 0.2;
        material.update();

        // Create particle system for an ethereal ambient effect
        const particleSystem = new pc.Entity();
        particleSystem.addComponent('particlesystem', {
            numParticles: 1000,
            lifetime: 5,
            rate: 0.02,
            scaleGraph: new pc.Curve([0, 0.3, 0.7]),
            colorGraph: new pc.CurveSet([new pc.Curve([0.4, 0.7, 1]), new pc.Curve([0.6, 0.9, 1]), new pc.Curve([0.7, 0.8, 1])]),
            velocityGraph: new pc.Curve([0, 0.5, 1.5]),
            blendType: pc.BLEND_ADDITIVE
        });
        app.root.addChild(particleSystem);

        // Handle window resize
        window.addEventListener('resize', () => {
            app.resizeCanvas(canvas.width, canvas.height);
        });

        // Set up audio context and analyzer for microphone input
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        // Request microphone access
        navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);
        }).catch((err) => {
            console.error('Error accessing microphone: ', err);
        });

        // Main animation loop
        app.on('update', (dt) => {
            analyser.getByteFrequencyData(dataArray);

            // Use FFT data to create a more ambient and fluid visual effect
            let avgFrequency = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
            const displacementScale = avgFrequency / 200;
            const hue = avgFrequency / 300;

            // Modify sphere material color and emissive based on ambient sound levels
            material.emissive.setHSL(hue, 0.8, 0.5);
            material.update();

            // Slow, subtle rotation of the sphere for a meditative feel
            sphere.rotate(0.05 * dt, 0.1 * dt, 0);

            // Update particle system for ambient movement
            particleSystem.rotate(0, 0.05 * dt, 0);
            particleSystem.particlesystem.velocityGraph = new pc.Curve([0, 0.5 + displacementScale, 1.5]);
        });
    </script>
</body>
</html>
